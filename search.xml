<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[python抓取数据汇总]]></title>
    <url>%2F2019%2F06%2F16%2Fpython%E6%8A%93%E5%8F%96%E6%95%B0%E6%8D%AE%E6%B1%87%E6%80%BB%2F</url>
    <content type="text"><![CDATA[星海暗流博客园首页新随笔联系订阅管理随笔 - 18 文章 - 0 评论 - 0python爬虫数据抓取方法汇总概要：利用python进行web数据抓取方法和实现。 1、python进行网页数据抓取有两种方式：一种是直接依据url链接来拼接使用get方法得到内容，一种是构建post请求改变对应参数来获得web返回的内容。 一、第一种方法通常用来获取静态页面内容，比如豆瓣电影内容分类下动画对应的链接： 1http://www.douban.com/tag/%E5%8A%A8%E7%94%BB/?focus=movie 纪录片对应的链接： http://www.douban.com/tag/%E7%BA%AA%E5%BD%95%E7%89%87/?focus=movie tag 与 /?foucus中间的代表关键字，每次将页面对应的关键字进行替换就能抓取到相应的页面。 二、第二种方法是通过使用post请求来进行获取web内容抓取，由于许多网站是动态网站，每次请求返回的对应链接都是无变化，所以不能直接使用get方法来抓取网站内容，基本思路是只能依据每次发送的post数据请求观察其中的参数，并模拟构造post请求实现相应的页面获取。 2、python简易代码实现web抓取： 复制代码 1 #coding=utf-8 2 3 import urllib,urllib2 4 5 #继续以抓取豆瓣电影分类链接为例 6 7 movie_list = [‘%E7%BA%AA%E5%BD%95%E7%89%87’,’%E6%96%87%E8%89%BA’,’%E5%8F%B2%E8%AF%97’] 8 9 for i in movie_list:10 url = http://www.douban.com/tag/%E5%8F%B2%E8%AF%97/?focus=movie11 url = url.replace(‘%E5%8F%B2%E8%AF%97’,i)12 request = urllib2.Request(url)13 html = urllib2.open(request)复制代码 3、使用phantomJS 模拟浏览器进行数据抓取 http://www.cnblogs.com/chenqingyang/p/3772673.html 这是我学习爬虫比较深入的一步了，大部分的网页抓取用urllib2都可以搞定，但是涉及到JavaScript的时候，urlopen就完全傻逼了，所以不得不用模拟浏览器，方法也有很多，此处我采用的是selenium2+phantomjs，原因在于： selenium2支持所有主流的浏览器和phantomjs这些无界面的浏览器，我开始打算用Chrome，但是发现需要安装一个什么Chrome驱动，于是就弃用了，选择phantomjs，而且这个名字听起来也比较洋气。 上网查了很多资料，发现网上selenium2+phantomjs的使用方法的中文资源十分欠缺，不得不阅读晦涩的官方文档，所以这里记下目前已经实现的操作，再加上一些我个人遇到的问题以及对应的解决方案。 背景知识： phantomjs是一个基于webkit的没有界面的浏览器，所以运行起来比完整的浏览器要高效。 selenium的英文原意是Se，化学元素，这里是一个测试web应用的工具，目前是2.42.1版本，和1版的区别在于2.0+中把WebDrive整合在了一起。 selenium2支持的Python版本：2.7, 3.2, 3.3 and 3.4 如果需要进行远程操作的话，就需要额外安装selenium server 安装： 先装selenium2，哪种方式装都可以，我一般都是直接下载压缩包，然后用python setup.py install命令来装，selenium 2.42.1的下载地址：https://pypi.python.org/pypi/selenium/2.42.1 然后下载phantomjs，https://bitbucket.org/ariya/phantomjs/downloads/phantomjs-1.9.7-windows.zip，解压后可以看到一个phantomjs.exe的文件 范例1： 复制代码复制代码 #coding=utf-8from selenium import webdriver driver = webdriver.PhantomJS(executable_path=’C:\Users\Gentlyguitar\Desktop\phantomjs-1.9.7-windows\phantomjs.exe’)driver.get(“http://duckduckgo.com/&quot;)driver.find_element_by_id(‘search_form_input_homepage’).send_keys(“Nirvana”)driver.find_element_by_id(“search_button_homepage”).click()print driver.current_urldriver.quit()复制代码复制代码其中的executable_path就是刚才phantomjs.exe的路径，运行结果： https://duckduckgo.com/?q=NirvanaWalk through of the example： 值得一提的是： get方法会一直等到页面被完全加载，然后才会继续程序 但是对于ajax： It’s worth noting that if your page uses a lot of AJAX on load then WebDriver may not know when it has completely loaded send_keys就是填充input 范例2： 复制代码复制代码 #coding=utf-8from selenium import webdriverfrom selenium.webdriver.common.keys import Keysfrom selenium.webdriver.support.ui import WebDriverWaitfrom selenium.webdriver import ActionChainsimport timeimport sys driver = webdriver.PhantomJS(executable_path=’C:\Users\Gentlyguitar\Desktop\phantomjs-1.9.7-windows\phantomjs.exe’)driver.get(“http://www.zhihu.com/#signin&quot;) #driver.find_element_by_name(‘email’).send_keys(‘your email’)driver.find_element_by_xpath(‘//input[@name=”password”]’).send_keys(‘your password’) #driver.find_element_by_xpath(‘//input[@name=”password”]’).send_keys(Keys.RETURN)time.sleep(2)driver.get_screenshot_as_file(‘show.png’) #driver.find_element_by_xpath(‘//button[@class=”sign-button”]’).click()driver.find_element_by_xpath(‘//form[@class=”zu-side-login-box”]’).submit() try: dr=WebDriverWait(driver,5) dr.until(lambda the_driver:the_driver.find_element_by_xpath(‘//a[@class=”zu-top-nav-userinfo “]’).is_displayed())except: print ‘登录失败’ sys.exit(0)driver.get_screenshot_as_file(‘show.png’) #user=driver.find_element_by_class_name(‘zu-top-nav-userinfo ‘) #webdriver.ActionChains(driver).move_to_element(user).perform() #移动鼠标到我的用户名loadmore=driver.find_element_by_xpath(‘//a[@id=”zh-load-more”]’)actions = ActionChains(driver)actions.move_to_element(loadmore)actions.click(loadmore)actions.perform()time.sleep(2)driver.get_screenshot_as_file(‘show.png’)print driver.current_urlprint driver.page_sourcedriver.quit()复制代码复制代码 这个程序完成的是，登陆知乎，然后能自动点击页面下方的“更多”，以载入更多的内容 Walk through of the example： from selenium.webdriver.common.keys import Keys，keys这个类就是键盘上的键，文中的send_keys(Keys.RETURN)就是按一个回车 from selenium.webdriver.support.ui import WebDriverWait是为了后面一个等待的操作 from selenium.webdriver import ActionChains是导入一个动作的类，这句话的写法，我找了很久 find_element推荐使用Xpath的方法，原因在于：优雅、通用、易学 Xpath表达式写法教程：http://www.ruanyifeng.com/blog/2009/07/xpath_path_expressions.html 值得注意的是，避免选择value带有空格的属性，譬如class = “country name”这种，不然会报错，大概compound class之类的错 检查用户密码是否输入正确的方法就是在填入后截屏看看 想要截屏，这么一句话就行： driver.get_screenshot_as_file(‘show.png’) 但是，这里的截屏是不带滚动条的，就是给你把整个页面全部照下来 try: dr=WebDriverWait(driver,5) dr.until(lambda the_driver:the_driver.find_element_by_xpath(‘//a[@class=”zu-top-nav-userinfo “]’).is_displayed())except: print ‘登录失败’ sys.exit(0) 是用来通过检查某个元素是否被加载来检查是否登录成功，我认为当个黑盒子用就可以了。其中5的解释：5秒内每隔500毫秒扫描1次页面变化，直到指定的元素 对于表单的提交，即可以选择登录按钮然后使用click方法，也可以选择表单然后使用submit方法，后者能应付没有登录按钮的情况，所以推荐使用submit() 对于一次点击，既可以使用click()，也可以使用一连串的action来实现，如文中： loadmore=driver.find_element_by_xpath(‘//a[@id=”zh-load-more”]’)actions = ActionChains(driver)actions.move_to_element(loadmore)actions.click(loadmore)actions.perform() 这5句话其实就相当于一句话，find element然后click，但是action的适用范围更广，譬如在这个例子中，要点击的是一个a标签对象，我不知道为什么直接用click不行，不起作用 print driver.current_urlprint driver.page_source即打印网页的两个属性：url和source 总结：除了能解决动态页面的问题以外，用selenium用来模拟登陆也比urllib2简单得多。 参考文献： http://www.realpython.com/blog/python/headless-selenium-testing-with-python-and-phantomjs/#.U5FXUvmSziE http://selenium-python.readthedocs.org/getting-started.html Xpath写法 http://www.cnblogs.com/paisen/p/3310067.html 4、使用代理防止抓取ip被封 实时动态抓取代理可用Ip,生成可用代理地址池 5、scrapy爬虫代理——利用crawlera神器，无需再寻找代理IP 由于工作需要，利用scrpay采集某个商业网站的数据。但是这个网站反扒非常厉害。因此不得不采用代理IP来做，但是做了几天后几乎能用的代理IP全被禁掉了。而且这种找代理、然后再验证的流程非常麻烦，于是博主想到了第三方平台crawlera. 一、crawlera平台注册 首先申明，注册是免费的，使用的话除了一些特殊定制外都是free的。 1、登录其网站 https://dash.scrapinghub.com/account/signup/ 填写用户名、密码、邮箱，注册一个crawlera账号并激活 2、创建Organizations,然后添加crawlear服务 然后点击 +Service ,在弹出的界面点击Crawlear，输入名字，选择信息就创建成功了。 创建成功过后点击你的Crawlear名字便可以看到API的详细信息。 二、部署到srcapy项目 1、安装scarpy-crawlera pip install 、easy_install 随便你采用什么安装方式都可以 1pip install scrapy-crawlera 2、修改settings.py 如果你之前设置过代理ip，那么请注释掉，加入crawlera的代理 12345DOWNLOADER_MIDDLEWARES = { # &apos;scrapy.contrib.downloadermiddleware.httpproxy.HttpProxyMiddleware&apos;: 110, # &apos;partent.middlewares.ProxyMiddleware&apos;: 100, ‘scrapy_crawlera.CrawleraMiddleware’: 600} 为了是crawlera生效，需要添加你创建的api信息（如果填写了API key的话，pass填空字符串便可） 123CRAWLERA_ENABLED = TrueCRAWLERA_USER = ‘‘CRAWLERA_PASS = ‘’ 为了达到更高的抓取效率，可以禁用Autothrottle扩展和增加并发请求的最大数量，以及设置下载超时，代码如下 1234CONCURRENT_REQUESTS = 32CONCURRENT_REQUESTS_PER_DOMAIN = 32AUTOTHROTTLE_ENABLED = FalseDOWNLOAD_TIMEOUT = 600 如果在代码中设置有 DOWNLOAD_DELAY的话，需要在setting.py中添加 1CRAWLERA_PRESERVE_DELAY = True 如果你的spider中保留了cookies,那么需要在Headr中添加 12345DEFAULT_REQUEST_HEADERS = { ‘Accept’: ‘text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,/;q=0.8’,‘Accept-Language’: ‘zh-CN,zh;q=0.8’, ‘X-Crawlera-Cookies’: ‘disable’}三、运行爬虫 这些都设置好了过后便可以运行你的爬虫了。这时所有的request都是通过crawlera发出的，信息如下 更多的crawlera信息请参考官方文档：http://doc.scrapinghub.com/index.html 分类: python标签: python好文要顶 关注我 收藏该文tornytooo关注 - 2粉丝 - 4+加关注1 0« 上一篇：解决：sudo: parse error in /etc/sudoers near line 24 …报错» 下一篇：使用 http://httpbin.org/ 验证代理地址posted @ 2015-12-05 16:30 tornytooo 阅读(3379) 评论(0) 编辑 收藏刷新评论刷新页面返回顶部注册用户登录后才能发表评论，请 登录 或 注册，访问网站首页。【推荐】超50万C++/C#源码: 大型实时仿真组态图形源码【前端】SpreadJS表格控件，可嵌入系统开发的在线Excel【培训】阿里P8面试官：什么样的人能进阿里【推荐】程序员问答平台，解决您开发中遇到的技术难题 相关博文：· 动态爬虫——selenium2搭载phantomjs入门范例· Python-爬虫-动态渲染页面抓取-（Selenium）的使用· 2017.07.28 Python网络爬虫之爬虫实战 今日影视2 获取JS加载的数据· 爬虫原理与数据抓取 一· Python爬虫实战：使用Selenium抓取QQ空间好友说说 最新新闻：· 5年间AMD股价上升800%！苏姿丰入选全球最佳CEO：黄仁勋落榜· 傲慢与偏见：消毒是如何引入外科手术的· 新买奔驰突然漏油 西安利之星被曝要求车主签署保密协议· 在东京生活的中国IT程序员· 美国“封杀”华为后：博通营收将少 20 亿美元» 更多新闻…昵称：tornytooo园龄：4年2个月粉丝：4关注：2+加关注&lt; 2019年6月 &gt;日 一 二 三 四 五 六26 27 28 29 30 31 12 3 4 5 6 7 89 10 11 12 13 14 1516 17 18 19 20 21 2223 24 25 26 27 28 2930 1 2 3 4 5 6搜索 常用链接我的随笔我的评论我的参与最新评论我的标签我的标签python(9)编程(6)Linux(4)工具(3)git(2)mongodb 数据库(1)故障维修(1)算法(1)随笔分类git(2)Linux(4)mongodb(1)python(10)sql(1)算法(1)随笔档案2016年10月 (2)2016年7月 (1)2016年5月 (2)2016年4月 (5)2016年3月 (2)2016年2月 (1)2015年12月 (1)2015年11月 (1)2015年10月 (1)2015年9月 (2)阅读排行榜 python特性、属性以及私有化(5061) 解决：sudo: parse error in /etc/sudoers near line 24 …报错(3929) python 装饰器、内部函数、闭包简单理解(3593) python爬虫数据抓取方法汇总(3379) python日志记录-logging模块(2028)推荐排行榜 python 装饰器、内部函数、闭包简单理解(4) python爬虫数据抓取方法汇总(1) python特性、属性以及私有化(1)Copyright ©2019 tornytooo]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一个不算计划的计划？]]></title>
    <url>%2F2019%2F06%2F16%2F%E4%B8%80%E4%B8%AA%E4%B8%8D%E7%AE%97%E8%AE%A1%E5%88%92%E7%9A%84%E8%AE%A1%E5%88%92%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[这其实应该算是一个不算计划的计划？简单的来说，就是我对现状的一个简单概述吧，或者说是对未来的一个简单的计划。 this is not easy，在过去的一年中，我的个人计划在某些方面来说可以说是一团乱码，不管是计划好的，或者说是没有计划好的，总之一切都可以说是一团乱麻，给我个人带来了很多的问题。 目前我需要进行的可以说是最重要的一件事就是有关我的未来考研的选择，我目前正在试图联系一位我非常喜欢的老师，如果这位老师答应的话，我会在下个半年开始准备考研。 这个选择相对于我来说的，其实可以算是一个比较简单的选择，首先是因为我的专业课不需要进行更改，在半年的时间里可以更加专注于公共课的学习，尤其是数学方面的学习。说实话，数学一直以来都是我的一个苦手科目，从小就是。所以我觉得我需要在下半个学期加强我对于数学的投入时间以及重视程度。 下一个问题则是有关我目前马上要进行的研究生毕设答辩，我对这个非常担心，因为我们组大神云集，但是每个小组是会有一定的进二辩的名额的，所以我还是很慌张的，我准备用今天下午的时间来准备一下老师们可能会问的问题。 然后是准备搬家以及租房子的事情，这两件事情我准备在答辩结束之后进行，给自己一点自信，自己一定不会进二辩的，虽然不是很清楚自己的这种蜜汁自信是哪里来的，但是还是要自信一点，最近很多事都是处于一种悬而未决的状态，真是的比较麻烦的一种感觉吧，毕竟我个人还是比较喜欢那种确定下来的感觉。但是没有办法嘛，选择才是人生的常态啊。]]></content>
      <categories>
        <category>计划</category>
      </categories>
      <tags>
        <tag>计划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[程序优化相关]]></title>
    <url>%2F2019%2F04%2F13%2F%E7%A8%8B%E5%BA%8F%E4%BC%98%E5%8C%96%E7%9B%B8%E5%85%B3%2F</url>
    <content type="text"><![CDATA[假设10*10的空间均匀分布着100个节点，我们的任务就是让无线传感器的生命周期最长，也就是使用的时间最长，能量损耗最低，假设种群的数目为100个，也就是说如果让种群处于最优的状态，那么基站就可以重复这100个循环的设置，让其使用的时间最长。 此处需要假设传感器的功率是可以由基站控制的，就是可以控制传感器是处于簇头模式还是普通的模式，或者是传感器模式。 假设簇头最多可以携带十个子节点]]></content>
      <categories>
        <category>学士论文相关</category>
      </categories>
      <tags>
        <tag>MATLAB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法工具箱及其使用]]></title>
    <url>%2F2019%2F04%2F08%2F%E7%AE%97%E6%B3%95%E5%B7%A5%E5%85%B7%E7%AE%B1%E5%8F%8A%E5%85%B6%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[一、ga函数 1[x,fval,exitflag,output,population,scores]=ga(fitnessfcn,nvars,……options) fitnessfcn为适应度句柄函数，nvars为目标函数的自变量函数，options为函数的属性设置； x为最佳染色体的返回值，fval为染色体的最佳适应度，exitflag为算法停止的原因，output为算法的输出结构，population为种群适应度的列向量，scores为最终的到的种群； 1234567891011121314151617程序：clearclcA=[1,1;-1,2;2,1]B=[2,2,3]lb=zeros(2,1);[x,fval,extflag]=ga(@lincontest6,2,A,B,[],[],lb)结果：x = 0.6670 1.3340fval = -8.2258extflag = 1 二、gaoptimest函数 1options=gaoptimest(&apos;paraml&apos;,value1,value2,……) 遗传算法本质上是一种启发式的随机运算，可以将前一次运行得到的最后种群作为下一次运行的初识种群。 1234[x,fval,reasn,output,final_pop]=ga(@fitnessfcn,nvars)最后一个输出变量final_pop返回的就是上一次运行得到的最后的种群，再将final_pop作为ga函数的初识种群，语法格式如下options=gaoptimest(&apos;InitialPopulation&apos;,final_pop);[x,fval,reason,output,final_pop2]=ga(@fitnessfcn,nvars,options);]]></content>
      <categories>
        <category>MATLAB</category>
      </categories>
      <tags>
        <tag>MATLAB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[遗传算法程序设计]]></title>
    <url>%2F2019%2F04%2F07%2F%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[一、程序设计 假设求函数, 1.初始化 12345%种群初始化function pop=initpop(popsize,chromlength)pop=round(rand(popsizechromlength));%rand随机产生每个单元为【0，1】行数为popsize，列数为chromlength的矩阵%round对每个矩阵进行圆整 initpop函数的功能是实现群体的初始化，popsize表示群体的大小，chromlength表示染色体的长度。 2.目标函数值 二进制数转化为十进制数 12345678%二进制数转换为十进制数function pop2=decodebinary(pop)[px,py]=size(pop); %求pop的行数和列数for i=1:py pop1(:,i)=2.^(py-i).*pop(:,i)endpop2=sum(pop,2); %求pop的每行之和end 二进制编码转化为十进制数 12345%将二进制编码转化为十进制数function pop2=decodechrom(pop,spoint,length)pop1=pop(:,spoint:spoint+length-1);pop2=decodebinary(pop1);end 计算目标函数值 123456%计算目标函数function [objvalue]=calobjvalue(pop)temp1=decodechrom(pop,1,10); %将pop的每一行转化为十进制数x=temp1*10/1023; %将二值域中的数转化为变量域中的数objvalue=10*sin(5*x)+7*cos(4*x);end 3.计算个体的期望值 123456789101112131415%计算个体的期望值function fitvalue=calfitvalue(objvalue)global Cmin;Cmin=0;[px,py]=size(objvalue);for i=i:px if objvalue(i)+Cmin&gt;0 temp=Cmin+objvalue(i); else temp=0.0; end fitvalue(i)=temp;endfitvalue=fitvalue&apos;end 4.选择复制 123456789101112131415161718%选择复制function [newpop]=selection(pop,fitvalue)totalfit=sum(fitvalue); %求适应度之和fitvalue=fitvalue/totalfit; %求每个个体被选中的机会fitvalue=cumsum(fitvalue);[px,py]=size(pop);ms=short(rand(px,1)); %从小到大排列fitin=1;newin=1;while newin&lt;=px if(ms(newin))&lt;fitvalue(fitin) newpop(newin)=pop(fitin); newin=newin+1; else fitin=fitin+1; endendend 5.交叉 123456789101112131415%交叉function [newpop]=crossover(pop,pc)[px,py]=size(pop);newpop=ones(size(pop));for i=1:2:px-1 if(rand&lt;pc) cpoint=round(rand*py); newpop(i,:)=[pop(i,1:cpoint),pop(i+1,cpoint+1:py)]; newpop(i+1,:)=[pop(i+1,1:cpoint),pop(i,cpoint+1:py)]; else newpop(i,:)=pop(i); newpop(i+1,:)=pop(i+1); endendend 6.变异 123456789101112131415161718192021%变异function [newpop]=mutation(pop,pm)[px,py]=size(pop);newpop=ones(size(pop));for i=1:px if(rand&lt;pm) mpoint=round(rand*py); if mpoint&lt;=0 mpoint=1; end newpop(i)=pop(i); if any(newpop(i,mpoint))==0 newpop(i,mpoint)=1; else newpop(i.mpoint)=0; end else newpop(i)=pop(i); endendend 7.求出群体中最大的适应值以及个体 123456789101112%求出群体中最大适应值以及个体function [bestindividual,bestfit]=best(pop,fitvalue)[px,py]=size(pop);bestindividual=pop(1,:);bestfit=fitvalue(i);for i=2:px if fitvalue(i)&gt;bestfit bestindividual=pop(i,:); bestfit=fitvalue(i); endendend 8.主程序 12345678910111213141516171819202122popsize=20;chromlength=10;pc=0.7;pm=0.005;pop=initpop(popsize,chromlength);for i=1:20 %迭代次数 [objvalue]=calobjvalue(pop); fitvalue=calfitvalue(objvalue); [newpop]=selection(pop,fitvalue); [newpop]=crossover(pop,pc); [newpop]=mutation(pop,pm); [bestindividual,bestfit]=best(pop,fitvalue); y(i)=max(bestfit); n(i)=i pop5=bestindividual; x(i)=decodechrom(pop5,1,chromlength)*10/1023; pop=newpop;endfplot(&apos;9*sin(5*x)+8*cos(4*x)&apos;,[0,15])hold onplot(x,y,&apos;r*&apos;)hold off 二、算法参数设计原则 1.种群的规模 当种群的规模过小的时候，就会出现近亲交配，产生病态基因；种群规模较大的时候，难以收敛。种群的规模的建议值应该是0-100. 2.变异概率 当变异的概率太小，种群的多样性下降的太快，导致有效基因的迅速消失，而且不容易修补；当变异的概率过大的时候，尽管种群的多样性得到保障，但是高阶模式的被破坏概率也会随之增大。变异的概率一般取值在0.0001-0.2之间。 3.交配概率 交配概率太大容易破坏已有的有利模式，随机性增大，容易错失最优个体；交配的概率太低则不能有效的更新种群。 4.进化代数 进化代数太小，种群还没有完全成熟，算法没有收敛；进化代数太大，算法可能已经收敛或者早熟，在执行下去没有意义，进化的代数的选择一般是100-500； 5.种群初始化]]></content>
      <categories>
        <category>学士论文相关</category>
      </categories>
      <tags>
        <tag>MATLAB</tag>
        <tag>遗传算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[matlab运算以及字符串]]></title>
    <url>%2F2019%2F04%2F07%2Fmatlab%E8%BF%90%E7%AE%97%E4%BB%A5%E5%8F%8A%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[一、算术运算 1.基本算术运算 矩阵加减运算 矩阵A和矩阵B必须是同型的矩阵 一个标量也可以和矩阵进行加减运算，这时把标量和矩阵中的每一个元素进行加减 1234567891011程序：A=[4,3;2,6]B=A-1结果：A = 4 3 2 6B = 3 2 1 5 矩阵乘法 矩阵乘法要求前一个的行和后一个的列相同 一个标量也可以和矩阵进行乘法运算 矩阵除法 矩阵除法有两种，一种是左除，一种是右除 A\B等效于A的逆左乘B矩阵 B/A等效于A的逆右乘矩阵B 矩阵的乘方 A^x要求A是矩阵，x是标量 2.点运算 两个矩阵进行点运算是指他们的对应元素进行相关的运算。 二、关系运算 符号 英文 &lt; lt &lt;= le &gt; gt &gt;= ge = eq ~= ne 两个标量相互比较，结果仍旧是标量 标量和矩阵进行比较，结果是矩阵 矩阵和矩阵进行比较，结果是矩阵 三、逻辑运算 and、or、not 矩阵和矩阵=矩阵 矩阵和标量=矩阵 标量和标量=标量 一、字符串的表示 在matlab中，字符串是用单引号括起来的字符序列，若字符串中的字符含有单引号，则该单引号字符要用两个单引号来表示 12将字符串倒排序revch=ch(end:-1:1) 二、字符串的操作 1.字符串的执行 eval作用是把字符串的内容作为对应的matlab命令来执行 12345678程序：t=pi;m=&apos;[t,sin(t),cos(t)]&apos;;y=eval(m)结果：y = 3.1416 0.0000 -1.0000 2.字符串和数值之间的转换 1234567程序：s1=&apos;matlab&apos;a=abs(s1)结果：a = 109 97 116 108 97 98 3.字符串的连接 要将字符串连接起来，有两个方法：字符串向量、strcat函数 1234567字符串向量：中括号将若干个字符串括起来程序：[&apos;study&apos;,&apos;hard&apos;]结果：ans =studyhard 123456strcat函数可以将若干个函数连接起来程序：strcat(&apos;study&apos;,&apos;hard&apos;)结果：ans =studyhard 4.字符串的比较 关系运算符或者字符串比较函数 123456利用关系运算符，比较的规则就是按照ASCII码逐个比较程序：&apos;wwwwz&apos;&gt;=&apos;qwert&apos;结果：ans = 1 1 1 1 1 1234strcmp(s1.s2) %用来比较两个字符串是否相等strcmp(s1,s2,n) %用来比较前n个字符串是否相等strcmpi(s1,s2) %忽略字母大小写，用来比较两个字符串是否相等strcmpi(s1,s2,n) %忽略字母的大小写，用来比较前n个字符是否相等 5.字符串的查找和替换 12findstr(s1,s2) %返回长的字符串在长的字符串中的开始位置strrep(s1,s2,s3) %将s1中的所有s2子字符串替换s3]]></content>
      <categories>
        <category>MATLAB</category>
      </categories>
      <tags>
        <tag>MATLAB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MATLAB常用内部函数]]></title>
    <url>%2F2019%2F04%2F07%2FMATLAB%E5%B8%B8%E7%94%A8%E5%86%85%E9%83%A8%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[一、常用数学函数 三角函数有以弧度为单位和角度为单位的，以角度为单位的函数在后面加上d abs可以求实数的绝对值、复数的模、字符串的ASCII码值 二、矩阵的超越函数 1.矩阵平方根 sqrtm(A)用来计算A的平方根123456789101112程序：A=[4,3;2,6]B=sqrtm(A)结果：A = 4 3 2 6B = 1.9171 0.6978 0.4652 2.3823 2.矩阵对数 logm(A)计算矩阵A的自然对数 3.矩阵指数 expm(A)求矩阵指数 4.普通矩阵函数 funm(A,@fun)对方阵A计算由fun定义的函数的矩阵函数值 但是不可以用sqrtm]]></content>
      <categories>
        <category>MATLAB</category>
      </categories>
      <tags>
        <tag>MATLAB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[matlab变量及其操作]]></title>
    <url>%2F2019%2F04%2F07%2Fmatlab%E5%8F%98%E9%87%8F%E5%8F%8A%E5%85%B6%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[一、变量与赋值语句 在matlab中，变量是字母为开头，后接字母、数字或者下划线的。 matlab区分大小写，标准函数必须用小写字母。 求解，其中， 12345678程序：x=sqrt(7)-2i;y=exp(pi/2);z=(5+cos(47*pi/180))/(1+abs(x-y))结果：z = 1.4395 二、预定义变量 尽量不要使用i和j做变量名，当有复数运算的时候，可能会出现错误。 三、变量的管理 1.内存变量的删除与修改 who可以显示当前变量，whos可以显示详细的信息 2.内存变量文件 可以使用save和load命令，把当前有用的一些变量的数值保存下来。 12save 文件名 [变量名表]load 文件名 [变量名表]]]></content>
      <categories>
        <category>MATLAB</category>
      </categories>
      <tags>
        <tag>MATLAB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MATLAB数值数据]]></title>
    <url>%2F2019%2F04%2F06%2FMATLAB%E6%95%B0%E5%80%BC%E6%95%B0%E6%8D%AE%2F</url>
    <content type="text"><![CDATA[一、matlab数值数据 1.数值数据类型的分类 整型 分为有符号数和无符号数：8、16、32、64 浮点型 matlab中浮点型的默认类型是double，浮点型分为single和double，分别是4和8 复型 分为实部和虚部，全部默认是双精度类型，其中虚部可以用i或者j表示 class函数可以用于获取某个数值的类型 12345程序：class(9)结果：ans =double 2.数据的输出格式 matlab内部的数据都是用双精度存储的，可以用format改变数据输出个格式 1format 格式符 matlab默认的格式是short 二、matlab矩阵的表示 1.矩阵的建立 利用直接输入法创建矩阵 矩阵中的元素用中括号括起来，按照行的顺序输入矩阵，同一行之间用逗号或者空格间隔，不同行的元素之间用分号间隔。 12345678程序：A=[1,2,3;4,5,6;7,8,9]结果：A = 1 2 3 4 5 6 7 8 9 利用已经创建好的矩阵建立更大的矩阵 12345678910111213程序：A=[1,2,3;4,5,6;7,8,9]B=[-1,-2,-3;-4,-5,-6;-7,-8,-9]C=[A,B;B,A]结果：C = 1 2 3 -1 -2 -3 4 5 6 -4 -5 -6 7 8 9 -7 -8 -9 -1 -2 -3 1 2 3 -4 -5 -6 4 5 6 -7 -8 -9 7 8 9 还可以用实部矩阵和虚部矩阵，构成复数矩阵 12345678910程序：R=[1,2,3;4,5,6]I=[6,7,8;9,10,11]ri=R+i*I结果：ri = 1.0000 + 6.0000i 2.0000 + 7.0000i 3.0000 + 8.0000i 4.0000 + 9.0000i 5.0000 +10.0000i 6.0000 +11.0000i 二、冒号表达式 1e1:e2:e3 %e1为初始值,e2为步长，e3为终止值 1linspace(a,b,n) %a,b代表初始值和终止值，其中n代表产生的元素的个数 三、矩阵元素的引用 1.矩阵元素的引用方式 矩阵元素通过下标来引用 1A(3,2)=200 %表示矩阵A第三行第二列的元素 如果给出的矩阵下标大于原来的行数或者列数，matlab会将矩阵自动扩充，扩充的矩阵元素置为0 矩阵元素通过序号来引用 矩阵元素按照列来存储 123456789101112程序：A=[1,2,3;4,5,6]A(3)结果：A= 1 2 3 4 5 6ans = 2 矩阵元素的序号和下标，可以用sub2ind和ind2sub来相互转换。 12D=sub2ind(S,I,J) %S表示要转换的矩阵的行数和列数，通常用size函数获取， %I表示要转换矩阵的行下标，J表示要转换矩阵的列下标。 12345678910111213程序：A=[1,2,3;4,5,6]D=sub2ind(size(A),[1,2;2,2],[1,1;3,2])结果：A = 1 2 3 4 5 6D = 1 2 6 4 12[I,J]=ind2sub(S,D) %S表示要转换的矩阵的行数和列数 %D是序号， 123456789101112程序：[I,J]=ind2sub([3,3],[1,3,5])结果：I = 1 3 2J = 1 1 2 2.利用冒号表达式获得子矩阵 A(i,j)表示A矩阵的i行j列，A(i,:)表示第i行的全部元素 可以用end表示最后一行 12345678910111213程序：A=[1,2,3;4,5,6;7,8,9]A(end,:)结果：A = 1 2 3 4 5 6 7 8 9ans = 7 8 9 3.利用空矩阵删除矩阵的元素 将某些元素从矩阵中删除，可以采用将其置为空矩阵。 1234567891011121314程序：A=[1,2,3;4,5,6;7,8,9]A(:,[2,3])=[]结果：A = 1 2 3 4 5 6 7 8 9A = 1 4 7 4.改变矩阵的形状 1reshape(A,m,n) %在矩阵总元素保持不变的情况下，将矩阵重新排列成m*n的二维矩阵 123456789101112131415程序：A=[1,2,3;4,5,6;7,8,9;10,11,12]reshape(A,3,4)结果：A = 1 2 3 4 5 6 7 8 9 10 11 12ans = 1 10 8 6 4 2 11 9 7 5 3 12 reshape仅仅改变逻辑结构，但是不改变原矩阵的元素个数及存储顺序（存储顺序是按照列来的）]]></content>
      <categories>
        <category>MATLAB</category>
      </categories>
      <tags>
        <tag>MATLAB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MATLAB基本操作]]></title>
    <url>%2F2019%2F04%2F04%2Fmatlab%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[一、交互式命令操作 1.命令行 一个命令行可以输入若干条命令，各个命令之间用逗号隔开，如果前一个后面有分号，就不用逗号 12p=15,m=36//此时运行会显示p和m的值p=15；m=36//此时运行只会显示m的值 2.续行符 假如第一行比较长的话，可以在第一行最后加上三个小黑点。 12p=15,... m=1 3.命令行的编辑 4.注释 注释以%开头 二、MATLAB功能演示 12x=-2*pi:pi/180:2*pi;plot(x,2.^(-abs(x)),&apos;:&apos;,x,sin(x)); 求方程2X5&#x2D;3X3&#x2B;71X2&#x2D;9X&#x2B;13&#x3D;0的全部根。 程序代码是： 12p=[2,0,-3,71,-9,13]; %建立多项式系数向量x=roots(p) %调用root函数求解方程组的全部根 求得的结果是： 123456x = -3.4914 + 0.0000i 1.6863 + 2.6947i 1.6863 - 2.6947i 0.0594 + 0.4251i 0.0594 - 0.4251i 求解线性方程 1232x+3y-z=08x+2y+3Z=445x+3y+9z=23 程序如下： 123a=[2,3,-1;8,2,3;45,3,9];b=[2;4;23];x=inv(a)*b %inv(a)用于求a的逆矩阵 运行结果如下： 1234x = 0.5531 0.2051 -0.2784 求解&#x222B;10xln&#x28;1&#x2B;x&#x29;dx 程序如下： 12f=@(x) x.*log(1+x);integral(f,0,1) 结果如下： 12ans = 0.2500]]></content>
      <categories>
        <category>MATLAB</category>
      </categories>
      <tags>
        <tag>MATLAB</tag>
        <tag>基本操作</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学士论文目录大纲]]></title>
    <url>%2F2019%2F04%2F04%2F%E5%AD%A6%E5%A3%AB%E8%AE%BA%E6%96%87%E7%9B%AE%E5%BD%95%E5%A4%A7%E7%BA%B2%2F</url>
    <content type="text"><![CDATA[一、摘要 无线传感器网络是什么？ 无线传感器现状的概述？ 无线传感器的现状？ 无线传感器面临的问题？ 本文讨论的问题? 关键词？ 二、绪论 2.1课题的研究背景以及研究的意义 无线传感器的起源和发展详细历程？ 无线传感器网路的特点？ 无线传感器网络发展到现在的主要问题是什么？ 针对这些主要问题的现有解决方法有哪些？ 2.2本文的主要研究问题和研究任务 2.3本文的创新点 三、无线传感器网络 无线传感器网络是…… 3.1无线传感器网络的结构 3.2无线传感器网络的特点 3.3无线传感网络节点结构 3.4传感器节点的限制因素 3.5无线传感器的应用 3.6无线传感器网络覆盖问题 3.7无线传感器网络覆盖技术参数 网络生命 覆盖率和连通度 算法复杂性与精确性 工作节点比 网路可扩展性支持 算法实施策略 四、遗传算法概述]]></content>
      <categories>
        <category>学士论文相关</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[学士论文参考文献]]></title>
    <url>%2F2019%2F04%2F03%2F%E5%AD%A6%E5%A3%AB%E8%AE%BA%E6%96%87%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE%2F</url>
    <content type="text"><![CDATA[1、基于遗传算法的无线传感器网络优化 孙雁鸣 2.基于遗传算法的无线传感器网络覆盖优化 江苏大学 曹美霞]]></content>
      <categories>
        <category>学士论文相关</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[基于遗传算法的无限传感器网络的优化]]></title>
    <url>%2F2019%2F03%2F31%2F%E5%9F%BA%E4%BA%8E%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95%E7%9A%84%E6%97%A0%E7%BA%BF%E4%BC%A0%E6%84%9F%E5%99%A8%E7%BD%91%E7%BB%9C%E7%9A%84%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[一、摘要 无线传感器网络=若干个传感器节点（低成本、低功耗、多功能） 有线网络布网费用高，维护繁琐 无线传感器网络的最大问题：无线床啊其节点的能量消耗极大，限制了网络的工作寿命 关键词：无线传感器网络，优化覆盖，遗传算法，优化 二、绪论 2.1 课题的研究背景以及研究的意义 无线传感器网络的研究起源于…… 无线传感器网络=无线通信技术+大量的传感器节点+自组织方式 大面积环境的数据+不适宜部署有线网络的领域 无线传感器网络具有成本低、鲁棒性高、功耗小、灵活性高、布网简单、智能化强、维护便捷 无线传感器大规模投入使用面临的问题： 能量供应问题：目前的解决方案包括高能电池、传感器网络能量收集技术、降低传感器功率、电池无线充电技术 节点失效及补充问题：无线传感器网中节点可能会出现周围节点通信不畅或者由于电池能量耗尽而脱离网络，如何修复失效节点或者重新构建网络，有效进行通信。 成本问题：无线传感器网络在实际使用中需要数量庞大的微型传感器节点，节点的成本就会制约网络的发展。 国内外研究现状 传感器网络按照对覆盖区域的不同要求，把覆盖问题分为区域覆盖、点覆盖、栅栏覆盖。 区域覆盖：柳立峰，在保证足够的网络覆盖能力的前提下，能够关闭掉冗余节点，减少网络的总能量的消耗。区域覆盖要求节点完全覆盖整个目标区域，而如何能够使网络区域中的每个点均被传感器节点覆盖是考虑最多的。 基于冗余节点判断的覆盖控制算法： 由于传感器节点分布密度高，某个点或某区域往往同时被多个节点覆盖，称为“覆盖冗余”。 基于多重K级覆盖算法： 如果被监测区域的每个点至少在K个传感器节点的感知范围内，则称该网络具有K级覆盖。 基于网络连通性的覆盖算法： 如果网络中任意两节点可以进行通信，则该网络是连通的。基于网络连通性的覆盖控制算法的研究目标是保持足够覆盖的前提下，选择最小工作节点数目在位置距离上满足全网通信。 点覆盖：将传感器节点划分成若干个不相交的集合，每个集合能够完全覆盖所有目标点。任何时刻只要有一个传感器节点集合处于工作状态，其他集合将被依次唤醒。 点覆盖的优化就是确定不相交集合的最大数，相当于延长了每个传感器两次激活的时间间隔，使得整个网络寿命也得到延长。 栅栏覆盖： 栅栏覆盖一般存在于战场环境下，在一片节点部署的区域内，目标可能以任何路径穿过这片区域。栅栏覆盖有两方面的内容：一是要敌方穿越我方区域时不被发现的概率最下；二是我方在穿越地方区域时不被发现的概率最大。 基于最差情形和最好情形的覆盖算法： 最大突破路径是指在一条路径上，每一个点距离最近节点的距离最大，那么目标在一定时间沿着这条路径穿越时不被发现的可能性最大。 最大支持路径：如果存在这样一条路径，其上的每一个点距离最近节点的距离最小，那么目标在一定的时间沿着这条路径穿越时被发现的可能性最大，这条路径就称为最大支持路径。 基于暴露模型的覆盖算法： 本文的主要研究内容： 介绍了无线传感器网络及其特点，并对传感器网络覆盖问题的国内外研究现状进行了分析和归纳。 采用了遗传算法对节点优化配置，提高了网络的覆盖能力。 通过MATLAB仿真，验证上述算法。 2.2 遗传算法的发展 遗传算法 高度并行 随机 自适应 基本理念来源于达尔文的遗传学说 GA在理论上具有解决任何寻优问题的能力，具有极其广泛的应用价值。 Holland教授 模式定理：优良个体的样本数目将以指数规律增长，从而确保了遗传算法是 一个能够用来搜寻最优可行解的过程。 2.3无线传感器网络研究的发展状况 2003年，美国《技术评论》杂志评出了对人类未来生活产生重大影响的新兴科技，被列为第一位的就是无线传感网络技术。 无线传感器网络最开始被用在军事的监视系统中 无线传感网络是集通信技术、传感器技术和计算技术于一身的产物 2.4 本文的应用背景 无线传感器在露天矿场的边坡检测的例子 2.5本文研究目的和主要任务 无线传感器网络最难解决的缺点是：和有线网络相比，无线传感器网络的工作周期极大的受到能源的限制。充电或者更换电池会限制网络中的节点的通信和数据的处理，但是个别节点失灵不会影响整体的工作。 优化无线传感器网络的关键是延长整个网络的工作寿命。 2.6 本文的创新点 三、无线传感网络 无线传感网络是…… 无线传感网络可以分为动态网络和静态网络两种。 3.1无线传感网络结构 无线传感网路主要由传感器节点、任务管理节点、汇聚节点组成。 传感器节点采集到的数据通过多跳网络或者单跳网络传输到簇头，再到汇聚节点，最终通过卫星或者互联网传输到管理节点。 传感器节点一般是微型的嵌入式系统，能力较弱，通过携带电池通电。无线传感器网络中汇聚节点的能力比较强，传感器网络和外部网络就是通过汇聚节点相连接的。 对于多跳网络来说，每个传感器节点必须兼顾终端和路由器的功能，主要功能：信息采集、数据存储和再次的转发。 对于单跳的网络来说，簇头节点就是路由器和终端。 3.2无线传感网络的特点 无线传感器网络相对于其他传统网络的特点： 组网的规模够大，可以进行动态组网或者静态组网，而且容错性加强 单跳、多跳、自组织：传感器的通信距离是有限的，当超过一定的距离的时候，自动组成簇，通过多跳的方式从簇头传递到汇聚节点。 低功耗：环境恶劣，更换电池不容易，所以传感器节点必须是低功耗的。 数据作为中心：传统网络中，每一个工作节点必须在全网中有唯一的一个编号作为其通信地址；但是在无线传感器网路中，获得所需要的数据是第一要务，数据是从哪里来的是不重要的。 通信的覆盖范围较小。 数据处理：传统网络的主要职责是数据传输，自终端上处理数据，中间的节点仅仅负责传输数据；但是对于无线传感网络来说，中间节点同时具备数据传输和数据处理的功能。 低成本：每个传感器节点都应该低成本，低价格。 计算能力有限：传感器节点的数目巨大，使得在设计单个节点的时候，要尽量降低制造成本，尽量往微型化方向发展，也使得单个节点自身的运算处理能力地下。 无线传感器网络规模较大，拓扑结构复杂：传感器节点的精确位置预先不能确定，节点之间的拓扑关系事先也不知道，所以传感器节点要具有一定的自组织能力，能够通过拓扑控制机制和网络协议自动形成监控数据的网络。 3.3无线传感网络节点结构 传感网络节点的组成通常是由四部分组成的：处理器模块、传感器模块、能量供应模块、无线通信模块 数据采集、数据传递、数据处理和能量供应 3.4传感器节点的限制因素 电源能量有限：处理器和传感器浪费的能量少，主要消耗在无线通信模块。（此处可以配图说明） 通信能力有限：E=kd^n。其中参数n的取值在2到4之间，干扰越大n的取值也越大，n的取值通常设置为3，随着距离的增加，能量的损耗也会增加，所以传感器之间的距离应该在100米以内。 3.5无线传感器的应用 军事领域 航空领域 救灾领域 工业自动化领域 电力传输系统 3.6无线传感器网络覆盖问题 根据覆盖对象的不同，将静态无线传感器网络的覆盖问题分为三类：区域覆盖、点覆盖、栅栏覆盖 区域覆盖要求目标区域内的每个点至少被一个节点覆盖； 点覆盖考虑的是对若干离散目标点的覆盖，节点随意部署在若干个离散目标点附近，将节点划分为若干个互不相交的节点，使得集合能够完全覆盖这些目标点。任意时刻只有一个节点集合工作，使其他集合全部处于休眠状态。 栅栏覆盖：关注网络对移动目标的检测能力，当移动目标沿着任意路径穿越网络部署区域，目标不被发现的概率最小。 3.7无线传感器网络覆盖技术参数 网络生命：传感器网络的监控使长期的，尽管单个传感器节点的成本随着微电子技术的发展不断进步而降低，但是数量众多的传感器节点费用仍旧比较高；并且单个节点的能量十分有限，传感器节点工作的环境一般十分恶劣，更换电池基本上不可能。如何最大程度的降低节点的能耗来延长网络的生命期是当前研究的一个重要问题。 覆盖率和连通度：覆盖率是指所有传感器覆盖的总面积与目标区域总面积的比值，覆盖率小于等于1. 连通度则是指网络中的任何一个节点都要至少与网络中的其他几个节点相连通，连通度至少为1. 算法复杂性与精确性 算法复杂度包括网络运行时间复杂度、算法的实现复杂度、网络内部节点之间的复杂同心度。算法的准确性，用来降低算法的复杂度，提高网络运行效率。 工作节点比 任一时刻工作节点的数量都小于网络中所部署的节点数量。在保证覆盖的服务质量，工作节点数量越小，网络能量消耗越小，则算法越有效，进而延长网络生存寿命。 网路可扩展性支持 节点的丢失与参与要求网络的可扩展性，没有可扩展性做保证，网络性能会随着规模的增加而降低。 算法实施策略 覆盖控制算法有三类：分布式、集中式、混合式 集中式算法的能量消耗较大、网络性能和算法精度较差。 分布式算法利用本地信息，能耗能量较小且网络性能等方面都较好。 四、遗传算法概述 遗传算法受到了生物进化理论的启发，GA以自然界中的优胜劣汰和生物遗传机制作为理论的基础。 简单阐述遗传算法的概念。 4.1基本遗传算法 Goldberg研究出的传统的GA，只使用选择算子、交叉算子和变异算子，是GA的雏形。 编码方式：二进制编码、浮点数编码、量子编码 适应度函数：适应度函数和目标函数，求解最大值和最小值的问题 适应尺度变换：所谓的适应尺度变换，就是为了解决GA在初期的早熟问题和GA在后期的竞争力变弱的问题。 GA初期的早熟问题：假设个体的数目相对较少，如果此时群体中有一部分个体的适应度相对较高，那么他们遗传到下一代的概率就会非常高，但是过多的相似的个体进入下一代之后，他们经过交叉和变异产生的后代的多样性会减少，导致GA的早熟现象。早熟问题的出现主要就是由选择算子的不当造成的。 GA的早熟现象的解决办法：在GA运行的初期，将排名靠前的那一部分的个体的适应度相对调低，使其进入下一代的比例相对减少，保持下一代的多样性。 GA运行到后期，由于全部的个体其实已经逐渐的逼急最优解，此时，大家的适应度相差不大，就会导致竞争的逐渐变弱，最后使得竞争变成了随机的选择。 GA后期的解决办法：当GA运行到后期的时候，把排名相对靠前的一部分的个体的适应度相对调高，提高竞争性，但是同时不能改变排名的原有顺序。 尺度变换的三种方法：线性尺度变换、乘幂尺度变换与指数尺度变换 线性尺度变换：F’=aF+b,其中F是原适应度。 a和b一般需要满足的条件：尺度变换后原种群的适应度的平均值等于全部种群中个体的新适应度的平均值（是否代表，前后的平均值需要保持一致？）；尺度变换后的最大值要与原适应度平均值的指定倍数要相等，就是F’max=CFmax. 乘幂尺度变换：新的适应度是原有适应度的幂次。 指数尺度变换： 选择算子 选择操作就是指从旧的种群中以一定的概率选取若干个个体遗传到下一代群体中，选择操作的是建立在适应度的评价的基础上。 GA的早熟问题就是选择算子的不当造成的，导致进化停止不前或者种群中适应度较大的个体会误导种群进化的方向，使遗传失去了多样性。 常见的选择操作策略：轮盘赌、随机竞争、最佳保留、均匀排序选择和随机联赛选择 选择选择操作策略与编码方式无关。 最优保存策略 由于适应度最佳的个体可能在选择、交叉和变异的过程中被破坏掉，种群的平均适应度会因此而降低并且会很大程度上影响到GA的运行效率以及收敛性，而且GA运行的过程中要尽可能的将种群中适应度最好的个体保留到下一代。 为了实现上面的目的，我们可以采用最优保存策略来完成优胜劣汰操作，任何交叉和变异操作都会对当前种群中适应度最高的个体失效，用这个最好的替换经过选择交叉变异后所产生的新一代中的最差的个体。 最优保存策略同样存在问题，它容易加速某个最优个体的扩散，算法的全局搜索能力受到了极大的限制，因此最优保存策略必须配合其他一些选择操作方法来使用。 交叉算子 交叉运算就是指从种群中选取两个个体，随机选择一点或者多点染色体进行位置交换，通过两个染色体的交换组合，来产生新的优秀个体。 交叉算法也是遗传算法区别于其他算法的主要特征。 常用的配对算法策略是：将种群中的M个优秀个体随机打乱，再组成M/2个配对个体组。 个体编码和交叉算子的设计必须被统一考虑。 单点交叉：设染色体的长度为L，则共有L-1个可能的交叉点位置，在[1，L-1]的范围内，随即的选区一个整数数值K作为交叉点，然后交叉K点之后的基因片段。 两点交叉：交叉的是两个点之间的基因片段。 算术交叉：算术交叉是指通过线性组合的两个父代个体出产两个新的个体，只是只有浮点数编码的个体才能进行算术交叉运算。 量子交叉：当两个相同的个体出现的时候，普通的交叉方法在遗传算法的运行中就不会再奏效。 但是量子具有相干的特性，我们可以利用量子的这个特点，构造出一种全新的交叉操作，全干扰交叉。 变异算子 变异操作是指个体编码串中的某些基因值变成其他的数值。 变异算子有效的维持了种群的多样性，早熟现象的得到了很好的控制。 基本位变异：指定某一位或者某几位基因的变异概率。这种操作方式只能改变几个基因的数值，而且变异发生的概率相对较低，作用的效果也不是很明显。 均匀变异：每个基因都有一定的概率产生变异。均匀变异适合应用在GA运行的初期。 遗传算法运行参数 遗传算法中需要提前设定的算法参数主要有：种群的大小M、终止进化的代数G、交叉概率Pe、变异概率Pm等。 种群大小的选择：种群数目过小，容易引起遗传算法的早熟，种群的数目过大，则会导致遗传算法的速度降低。M的取值范围通常应该是20-100. 终止进化代数G：决定遗传算法运行的到哪一代停止。 交叉概率Pe：当交叉概率过大的时候，种群的优良模式会很容易受到破坏，但是交叉概率过小的时候，产生新的个体的速度会变慢。取值通常应该在0.4-0.99比较合适。 变异概率Pm：取值过大，种群中较好的个体可能被破坏掉；当取值过小，产生新个体和抑制早熟就会比较差，变异概率的通常取值是0.0001-0.1. 五、无线传感网络模型构造 5.1网络模型 10*10的正方形网格，传感器节点被放置在网格的100个交叉点上。假设传感器是相同的，但是传感器的状态是不同的。这里假设传感器节点能量是可以控制的，可以人为的在基站调节传感器节点的发射功率。 节点被分到不同的簇，每一个簇中选出一个节点作为簇头，簇中的节点直接与簇头进行通讯（单跳），簇头与远程基站进行通讯（单跳） 簇头的能量消耗比较大。 无线传感器的网路覆盖类型： 根据应用可以分为时间驱动类型和事件驱动类型。（时间驱动类型是指按照时间启动，事件驱动类型是指只有当发生一定的事件才会启动，Q：是否是指没有发生事件的时候，传感器处于一种低功耗的问题） 根据覆盖对象，静态传感器网络可以分为：目标覆盖、栅栏覆盖和区域覆盖。（Q：什么是栅栏覆盖） 根据节点的部署方式，可以分为节点确定性部署，随机性部署以及可移动部署。 根据节点的类型，可分为同构节点覆盖、异构节点覆盖以及混合节点覆盖等。 从应用角度归纳覆盖的分类 按目标特性：静态目标覆盖和动态目标覆盖。静态目标覆盖主要考虑的是覆盖的全面性以及对覆盖冗余节点的处理。 按配置方式：根据节点是否需要知道自身位置信息，可以将覆盖问题分为确定性覆盖、随机性覆盖。随机覆盖所要解决的问题是对节点随机分布在传感区域而预先没有得到自身位置及进行讨论。 按感知类型：目前的感知类型主要有两类：二进制感知模型和指数感知模型。 5.2适应度函数的建立 休眠参数 休眠节点误差：用来限制无线传感器网络中休眠节点的数量。当无线传感器网络休眠节点的数目超过总节点数的50%的时候，网络的连通性就会受到破坏。 连通性参数 节点覆盖率： 簇中节点个数误差：每个簇最多携带的节点数目应该是有限制的。 超限节点误差：统计超出通信距离的传感器节点占整个网络节点数的比例。 能量参数 网络总体能量的消耗：簇头节点、高功率发射节点、低功率发射节点、休眠节点，其中休眠节点的能耗为0； 通讯能量损耗：节点与簇头节点进行通讯所消耗的能量。 电池惩罚值：影响节点下一个周期的工作状态，从而使网络的工作时间最长。 六、基于遗传算法无线传感网络能量优化实验 6.1 串行遗传算法实验 网络中节点的四种工作模式：簇头模式、休眠模式、高功率发射模式、低功率发射模式。 编码机制 采用二进制编码，01编码即可 经过实验种群数目是80，单点交换概率为0.8，突变概率为0.005，适应度的数值最大。 尽量可能让运行能量消耗最小，簇头节点减少，低功率发射节点增加，高功率发射节点减少。 6.2 并行遗传算法实验 使用串行遗传算法进行实验，要进行大量适应度的计算，所以进行并行遗传算法。 应用基于种群进行分组遗传算法，一个种群划分成多组种群，把划分好的子种群及遗传算法分别放置在不同的电脑上。 将各个电脑上的程序和数据运行一个周期，将各个电脑之间再以适当的方式进行一些信息的交换。]]></content>
      <categories>
        <category>学士论文相关</category>
      </categories>
      <tags>
        <tag>遗传算法</tag>
        <tag>无线传感器网络优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初识遗传算法]]></title>
    <url>%2F2019%2F03%2F31%2F%E5%88%9D%E8%AF%86%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[一、遗传算法基本知识 1.遗传算法的遗传操作：选择、交叉、变异（选择出好的近似解，然后进行交叉和变异，就会产生新的种群） 交叉(crossover)：两个染色体的某一相同位置处DNA被切断，前后两串分别交叉组合形成两个新的染色体。也称基因重组或杂交； 2.遗传算法的核心内容：参数编码、初识群体的设定、适应度函数的设计、遗传操作设计、控制参数 适应度：度量某个物种对于生存环境的适应程度。 3.遗传问题是从种群开始的，种群是由个体组成的，个体实际上是染色体带有特征的实体。染色体中控制某一特征的基因组合，决定了该特征的外在表现形式，所以在一开始需要实现从表现型到基因型的映射，即编码工作。 4.遗传算法可以看作是多元函数求最优解，多元函数可能存在很多的极大值或者极小值，遗传算法就是找出其中的最大值或者最小值。 寻找最大值的方法就像袋鼠跳，我们希望袋鼠会跳到最高的位置。 5.袋鼠跳的几种方式 爬山算法：一只袋鼠在一个山峰，于是朝着不远处的另一个更高的山峰跳过去，但是第二个山峰不一定就是最高的。局部的最优解不一定是全局的最优解，有可能更远的地方有一个比现在的山峰还要高的山峰，但是那个山峰超出了袋鼠的跳跃范围（或者说认为设定的约束条件） 模拟退火： 遗传算法：有很多袋鼠，它们降落到喜玛拉雅山脉的任意地方。这些袋鼠并不知道它们的任务是寻找珠穆朗玛峰。但每过几年，就在一些海拔高度较低的地方射杀一些袋鼠。于是，不断有袋鼠死于海拔较低的地方，而越是在海拔高的袋鼠越是能活得更久，也越有机会生儿育女。就这样经过许多年，这些袋鼠们竟然都不自觉地聚拢到了一个个的山峰上，可是在所有的袋鼠中，只有聚拢到珠穆朗玛峰的袋鼠被带回了美丽的澳洲。 二、遗传算法的实现过程 1、建立表现型和基因型的映射关系 假设我们需要找出最适应在寒冷地区生存的人类的某一条染色体的编码，假设该染色体上有十个基因片段，十个基因片段的排序决定了人类对于寒冷的耐受性。 2.随机初始化一个种群 随机初始化一个种群，意味着这一个种群中人，十个基因的排列顺序的速记排列的。 3.适应度的评估 接下来测试每个人对寒冷的耐受能力，当然是越能忍受寒冷越好。 4.选择 按照某种规定做优化的选择，比如每隔一段时间淘汰掉耐受能力最后的20%。 5.基因的交叉 让生存下来的人类繁衍后代，然后产生下一代袋鼠。 6.基因的变异 让存活下来的一部分的基因序列随机改变一下排序。（应规定随机变异的程度，比如不能超过四个基因的位置变化之类的，或者不允许第一个和最后一个基因突变） 总结：遗传算法不需要费心去寻找最优解，而是把那些不好的存在抹杀就可以了. 三、遗传算法的具体实现 1、编码 遗传算法的编码主要有三类：二进制编码、浮点编码、符号编码、量子编码 1.1二进制编码：就是用0和1进行编码 二进制编码的缺点：个体长度较短的时候，可能达不到精度的要求；个体长度较大的手，会增加遗传算的搜索空间（当个体的长度较短的时候，比如只有两个01、00、10、11，假设寻找会使人的头发显现黑色基因，通过最简单的比较就可知道那两个比较好，假设是11和10，利用这两个进行杂交会出现的结果就是10和11，这时候就无法判断到底是哪个比较好了）（当个体的长度过长的手，交叉或者变异之后的变数会增大，会给搜索最佳算法增加难度） 假设用ｎ位二进制来编码，则二进制编码的精度是（Umax-Umin）/(2^n-1), 1.2浮点编码：个体的每个基因值用某一范围内的一个浮点数来表示 浮点编码的优点： 适用于在遗传算法中表示范围较大的数值 适用于精度要求较高的遗传算法 适用于较大空间的遗传搜索 降低了遗传算法的计算复杂性，提高了运算的速率 1.3符号编码法 1.4量子编码方法 每一个量子位除了0或者1以外，还可以处于两者的叠加状态，叠加状态是指0和1的任意线性叠加。 2、袋鼠的染色体编码 3、评价个体的适应度-适应度函数 目标函数与适应度函数：求解最大值和最小值的问题 求解最大值的问题 F(X)=f(X)+Cmin,if f(X)+Cmin &gt; 0 =0 ,if f(X)+Cmin &lt;= 0 其中Cmin为一个相对较小的数 求解最小值的问题 F(X)=Cmax-f(X),if f(X)&lt;Cmax =0 ,if f(X)&gt;Cmax 适应度尺度变换 GA的早熟现象：GA运行的初期阶段，如果种群的数目相对较小，而且在种群中存在一部分适应度相对比较好的个体，这些个体就会比较容易生存下去，这些相同或者近似的个体繁殖出来的下一代，多样性会受到影响，这就是GA的早熟现象. GA的早熟现象的解决办法：我们可以在初期降低那些适应度的数值相对较高的个体的适应度，使其在下一代中的比例相对降低，但是同时又不会改变排列顺序（这就是适应度的缩小） GA运行的后期阶段：在GA运行的后期阶段，因为种群中所有个体的适应度相差不大，就会导致竞争变弱，导致竞争过程变成一种随机的选择过程，因此在此时我们需要将那些排名相对较高的个体的适应度调高一些，但是同时不改变排列的原有顺序。（这就是适应度的扩大） 适应尺度的变换一共有三种变换方法：线性变换、乘幂变换、指数变换 线性变换：F=aF+b ,其中a和b的数值要满足一定的条件。 新的种群适应度的平均值要和原有的种群适应度的平均值保持一致；而且新的种群的最大的适应度的数值，应该满足Fmax=CFmax 乘幂变换： 尺度变换： 4、选择函数 轮盘赌选择：个体进入下一代的概率=个体的适应度数值/整体的适应度数值和（选择误差比较大） 随机竞争选择：每次按照轮盘赌选择一对个体，然后让这两个个体进行竞争，适应度高的被选中，如此反复。（但是轮盘赌选择的个体是如何选择的） 最佳保留选择：首先按轮盘赌选择方法执行遗传算法的选择操作，然后将当前群体中适应度最高的个体结构完整地复制到下一代群体中。（那么适应度不高的个体应该如何选择） 期望值选择：第一步，计算群体中每个个体在下一代群体中的生存期望数值N；第二步，若某一个体被选中参与交叉运算，则它在下一代中的生存期望数目减去0.5，若某一个体未 被选中参与交叉运算，则它在下一代中的生存期望数目减去1.0。（此处的选择是如何选择的）；第三步，随着选择过程的进行，若某一个体的生存期望数目小于0时，则该个体就不再有机会被选中。 确定式选择：第一步，计算群体中的各个个体在下一代群体中的生存期望数目；第二步，用N的整数部分确定各个对应个体在下一代群体中的生存数目；第三步，用N的小数部分对个体进行降序排列，顺序去前M个个体加入下一代群体中。（假设得出来的N的数值分别为3.1、3.2、3.5、4.5、5.5，表示每一个在下一代中的期望的数目有3、3、3、4、5，其中3的有三个，所以可以降序排列，取第一个，就是3.3） 无回放余数随机选择： 均匀排列：对群体中的所有个体按照适应度的大小进行排序，根据排序来分配每个个体被选中的概率。 最佳保存策略：适应度最高的不参与交叉和变异运算，而是用这个来代替，经过交叉和变异之后，适应度最低的个体。 随机联赛选择：随机选取N个，然后将适应度最高的一个个体遗传到下一代中。 排挤选择：新产生的子代，会替代或者排挤相似的旧的父代的个体，提高群体的多样性。 5、交叉 所谓交叉，是指相互配对的两个染色体，按照某种方式交互部分基因，从而形成两个新的个体。 适用于二进制和浮点编码个体的交叉算子： 单点交叉：只有一个交叉点，在该点交换部分染色体。 两点交叉和多点交叉： 均匀交叉：每个基因片段以相同的交叉概率进行交换，形成两个新的个体。 算术交叉：由两个个体的线性组合而产生出两个新的个体。该操作对象一般是由浮点数编码表示的个体。 6.变异 所谓变异，就是指某个基因，用其他等位基因来替换。 变异算子： 基本位变异：对个体编码串中以变异概率、随机指定的某一位或某几位仅因座上的值做变异运算。 均匀变异：用一个范围内的随机数，替换编码串中的原有数值（用一个较小的概率） 边界变异：随机的取基因座上的两个对应边界基因值之一去替代原有基因值。特别适用于最优点位于或接近于可行解的边界时的一类问题。（什么是边界基因值） 非均匀变异： 高斯近似变异：]]></content>
      <categories>
        <category>学士论文相关</category>
      </categories>
      <tags>
        <tag>遗传算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[123]]></title>
    <url>%2F2019%2F03%2F07%2F123%2F</url>
    <content type="text"></content>
  </entry>
</search>
