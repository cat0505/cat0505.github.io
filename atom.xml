<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>忽如远行客</title>
  <icon>https://www.gravatar.com/avatar/cccd8c60c09f9d87466d6201f5ee7f33</icon>
  <subtitle>人生天地间，忽如远行客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-04-06T04:13:46.943Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>二次元阿宅</name>
    <email>此处省略</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>MATLAB数值数据</title>
    <link href="http://yoursite.com/2019/04/06/MATLAB%E6%95%B0%E5%80%BC%E6%95%B0%E6%8D%AE/"/>
    <id>http://yoursite.com/2019/04/06/MATLAB数值数据/</id>
    <published>2019-04-06T01:43:50.000Z</published>
    <updated>2019-04-06T04:13:46.943Z</updated>
    
    <content type="html"><![CDATA[<p>一、matlab数值数据</p><p>1.数值数据类型的分类</p><hr><p>整型</p><p>分为有符号数和无符号数：8、16、32、64</p><hr><p>浮点型</p><p>matlab中浮点型的默认类型是double，浮点型分为single和double，分别是4和8</p><hr><p>复型</p><p>分为实部和虚部，全部默认是双精度类型，其中虚部可以用i或者j表示</p><p>class函数可以用于获取某个数值的类型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">程序：</span><br><span class="line">class(9)</span><br><span class="line">结果：</span><br><span class="line">ans =</span><br><span class="line">double</span><br></pre></td></tr></table></figure><hr><p>2.数据的输出格式</p><p>matlab内部的数据都是用双精度存储的，可以用format改变数据输出个格式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">format 格式符</span><br></pre></td></tr></table></figure><p>matlab默认的格式是short</p><p>二、matlab矩阵的表示</p><p>1.矩阵的建立</p><hr><p>利用直接输入法创建矩阵</p><p>矩阵中的元素用中括号括起来，按照行的顺序输入矩阵，同一行之间用逗号或者空格间隔，不同行的元素之间用分号间隔。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">程序：</span><br><span class="line">A=[1,2,3;4,5,6;7,8,9]</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">A =</span><br><span class="line">     1     2     3</span><br><span class="line">     4     5     6</span><br><span class="line">     7     8     9</span><br></pre></td></tr></table></figure><hr><p>利用已经创建好的矩阵建立更大的矩阵</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">程序：</span><br><span class="line">A=[1,2,3;4,5,6;7,8,9]</span><br><span class="line">B=[-1,-2,-3;-4,-5,-6;-7,-8,-9]</span><br><span class="line">C=[A,B;B,A]</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">C =</span><br><span class="line">     1     2     3    -1    -2    -3</span><br><span class="line">     4     5     6    -4    -5    -6</span><br><span class="line">     7     8     9    -7    -8    -9</span><br><span class="line">    -1    -2    -3     1     2     3</span><br><span class="line">    -4    -5    -6     4     5     6</span><br><span class="line">    -7    -8    -9     7     8     9</span><br></pre></td></tr></table></figure><p>还可以用实部矩阵和虚部矩阵，构成复数矩阵</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">程序：</span><br><span class="line">R=[1,2,3;4,5,6]</span><br><span class="line">I=[6,7,8;9,10,11]</span><br><span class="line">ri=R+i*I</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line"></span><br><span class="line">ri =</span><br><span class="line">   1.0000 + 6.0000i   2.0000 + 7.0000i   3.0000 + 8.0000i</span><br><span class="line">   4.0000 + 9.0000i   5.0000 +10.0000i   6.0000 +11.0000i</span><br></pre></td></tr></table></figure><hr><p>二、冒号表达式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">e1:e2:e3 %e1为初始值,e2为步长，e3为终止值</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">linspace(a,b,n) %a,b代表初始值和终止值，其中n代表产生的元素的个数</span><br></pre></td></tr></table></figure><hr><p>三、矩阵元素的引用</p><p>1.矩阵元素的引用方式</p><hr><p>矩阵元素通过下标来引用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A(3,2)=200 %表示矩阵A第三行第二列的元素</span><br></pre></td></tr></table></figure><p>如果给出的矩阵下标大于原来的行数或者列数，matlab会将矩阵自动扩充，扩充的矩阵元素置为0</p><hr><p>矩阵元素通过序号来引用</p><p>矩阵元素按照列来存储</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">程序：</span><br><span class="line">A=[1,2,3;4,5,6]</span><br><span class="line">A(3)</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">A=</span><br><span class="line">    1     2     3</span><br><span class="line">    4     5     6</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ans =</span><br><span class="line">    2</span><br></pre></td></tr></table></figure><p>矩阵元素的序号和下标，可以用sub2ind和ind2sub来相互转换。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">D=sub2ind(S,I,J) %S表示要转换的矩阵的行数和列数，通常用size函数获取，</span><br><span class="line">                 %I表示要转换矩阵的行下标，J表示要转换矩阵的列下标。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">程序：</span><br><span class="line">A=[1,2,3;4,5,6]</span><br><span class="line">D=sub2ind(size(A),[1,2;2,2],[1,1;3,2])</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">A =</span><br><span class="line">     1     2     3</span><br><span class="line">     4     5     6</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">D =</span><br><span class="line">     1     2</span><br><span class="line">     6     4</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[I,J]=ind2sub(S,D) %S表示要转换的矩阵的行数和列数</span><br><span class="line">                   %D是序号，</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">程序：</span><br><span class="line">[I,J]=ind2sub([3,3],[1,3,5])</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">I =</span><br><span class="line"></span><br><span class="line">     1     3     2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">J =</span><br><span class="line"></span><br><span class="line">     1     1     2</span><br></pre></td></tr></table></figure><hr><p>2.利用冒号表达式获得子矩阵</p><p>A(i,j)表示A矩阵的i行j列，A(i,:)表示第i行的全部元素</p><p>可以用end表示最后一行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">程序：</span><br><span class="line">A=[1,2,3;4,5,6;7,8,9]</span><br><span class="line">A(end,:)</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">A =</span><br><span class="line">     1     2     3</span><br><span class="line">     4     5     6</span><br><span class="line">     7     8     9</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ans =</span><br><span class="line">     7     8     9</span><br></pre></td></tr></table></figure><hr><p>3.利用空矩阵删除矩阵的元素</p><p>将某些元素从矩阵中删除，可以采用将其置为空矩阵。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">程序：</span><br><span class="line">A=[1,2,3;4,5,6;7,8,9]</span><br><span class="line">A(:,[2,3])=[]</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">A =</span><br><span class="line">     1     2     3</span><br><span class="line">     4     5     6</span><br><span class="line">     7     8     9</span><br><span class="line"></span><br><span class="line">A =</span><br><span class="line">     1</span><br><span class="line">     4</span><br><span class="line">     7</span><br></pre></td></tr></table></figure><hr><p>4.改变矩阵的形状</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reshape(A,m,n) %在矩阵总元素保持不变的情况下，将矩阵重新排列成m*n的二维矩阵</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">程序：</span><br><span class="line">A=[1,2,3;4,5,6;7,8,9;10,11,12]</span><br><span class="line">reshape(A,3,4)</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">A =</span><br><span class="line">     1     2     3</span><br><span class="line">     4     5     6</span><br><span class="line">     7     8     9</span><br><span class="line">    10    11    12</span><br><span class="line"></span><br><span class="line">ans =</span><br><span class="line">     1    10     8     6</span><br><span class="line">     4     2    11     9</span><br><span class="line">     7     5     3    12</span><br></pre></td></tr></table></figure><p>reshape仅仅改变逻辑结构，但是不改变原矩阵的元素个数及存储顺序（存储顺序是按照列来的）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一、matlab数值数据&lt;/p&gt;
&lt;p&gt;1.数值数据类型的分类&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;整型&lt;/p&gt;
&lt;p&gt;分为有符号数和无符号数：8、16、32、64&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;浮点型&lt;/p&gt;
&lt;p&gt;matlab中浮点型的默认类型是double，浮点型分为single和do
      
    
    </summary>
    
      <category term="MATLAB" scheme="http://yoursite.com/categories/MATLAB/"/>
    
    
      <category term="MATLAB" scheme="http://yoursite.com/tags/MATLAB/"/>
    
  </entry>
  
  <entry>
    <title>MATLAB基本操作</title>
    <link href="http://yoursite.com/2019/04/04/matlab%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
    <id>http://yoursite.com/2019/04/04/matlab基本操作/</id>
    <published>2019-04-04T02:51:38.000Z</published>
    <updated>2019-04-06T01:43:57.284Z</updated>
    
    <content type="html"><![CDATA[<p>一、交互式命令操作</p><p>1.命令行</p><p>一个命令行可以输入若干条命令，各个命令之间用逗号隔开，如果前一个后面有分号，就不用逗号</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p=15,m=36//此时运行会显示p和m的值</span><br><span class="line">p=15；m=36//此时运行只会显示m的值</span><br></pre></td></tr></table></figure><p>2.续行符</p><p>假如第一行比较长的话，可以在第一行最后加上三个小黑点。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p=15,...</span><br><span class="line">    m=1</span><br></pre></td></tr></table></figure><p>3.命令行的编辑</p><p>4.注释</p><p>注释以%开头</p><p>二、MATLAB功能演示</p><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x=-2*pi:pi/180:2*pi;</span><br><span class="line">plot(x,2.^(-abs(x)),&apos;:&apos;,x,sin(x));</span><br></pre></td></tr></table></figure><img src="/2019/04/04/matlab基本操作/函数图像.jpg" title="函数图像"><hr><p>求方程<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mn>2</mn><mi mathvariant="italic">X</mi><msup><mrow></mrow><mrow><mn>5</mn></mrow></msup><mo>&#x2D;</mo><mn>3</mn><mi mathvariant="italic">X</mi><msup><mrow></mrow><mrow><mn>3</mn></mrow></msup><mo>&#x2B;</mo><mn>7</mn><mn>1</mn><mi mathvariant="italic">X</mi><msup><mrow></mrow><mrow><mn>2</mn></mrow></msup><mo>&#x2D;</mo><mn>9</mn><mi mathvariant="italic">X</mi><mo>&#x2B;</mo><mn>1</mn><mn>3</mn><mo>&#x3D;</mo><mn>0</mn></mrow></math>的全部根。</p><p>程序代码是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p=[2,0,-3,71,-9,13]; %建立多项式系数向量</span><br><span class="line">x=roots(p) %调用root函数求解方程组的全部根</span><br></pre></td></tr></table></figure><p>求得的结果是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">x =</span><br><span class="line">  -3.4914 + 0.0000i</span><br><span class="line">   1.6863 + 2.6947i</span><br><span class="line">   1.6863 - 2.6947i</span><br><span class="line">   0.0594 + 0.4251i</span><br><span class="line">   0.0594 - 0.4251i</span><br></pre></td></tr></table></figure><hr><p>求解线性方程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2x+3y-z=0</span><br><span class="line">8x+2y+3Z=4</span><br><span class="line">45x+3y+9z=23</span><br></pre></td></tr></table></figure><p>程序如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a=[2,3,-1;8,2,3;45,3,9];</span><br><span class="line">b=[2;4;23];</span><br><span class="line">x=inv(a)*b %inv(a)用于求a的逆矩阵</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x =</span><br><span class="line">    0.5531</span><br><span class="line">    0.2051</span><br><span class="line">   -0.2784</span><br></pre></td></tr></table></figure><hr><p>求解<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mo>&#x222B;</mo><mrow><mn>1</mn></mrow><mrow><mn>0</mn></mrow></msubsup><mrow><mi mathvariant="italic">x</mi><mi mathvariant="italic">l</mi><mi mathvariant="italic">n</mi><mo>&#x28;</mo><mn>1</mn><mo>&#x2B;</mo><mi mathvariant="italic">x</mi><mo>&#x29;</mo><mi mathvariant="italic">d</mi><mi mathvariant="italic">x</mi></mrow></mrow></math></p><p>程序如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f=@(x) x.*log(1+x);</span><br><span class="line">integral(f,0,1)</span><br></pre></td></tr></table></figure><p>结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ans =</span><br><span class="line">    0.2500</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一、交互式命令操作&lt;/p&gt;
&lt;p&gt;1.命令行&lt;/p&gt;
&lt;p&gt;一个命令行可以输入若干条命令，各个命令之间用逗号隔开，如果前一个后面有分号，就不用逗号&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutte
      
    
    </summary>
    
      <category term="MATLAB" scheme="http://yoursite.com/categories/MATLAB/"/>
    
    
      <category term="MATLAB" scheme="http://yoursite.com/tags/MATLAB/"/>
    
      <category term="基本操作" scheme="http://yoursite.com/tags/%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>学士论文目录大纲</title>
    <link href="http://yoursite.com/2019/04/04/%E5%AD%A6%E5%A3%AB%E8%AE%BA%E6%96%87%E7%9B%AE%E5%BD%95%E5%A4%A7%E7%BA%B2/"/>
    <id>http://yoursite.com/2019/04/04/学士论文目录大纲/</id>
    <published>2019-04-04T02:27:20.000Z</published>
    <updated>2019-04-04T02:46:15.101Z</updated>
    
    <content type="html"><![CDATA[<p>一、摘要</p><p>无线传感器网络是什么？</p><p>无线传感器现状的概述？</p><p>无线传感器的现状？</p><p>无线传感器面临的问题？</p><p>本文讨论的问题?</p><p>关键词？</p><p>二、绪论</p><hr><p>2.1课题的研究背景以及研究的意义</p><p>无线传感器的起源和发展详细历程？</p><p>无线传感器网路的特点？</p><p>无线传感器网络发展到现在的主要问题是什么？</p><p>针对这些主要问题的现有解决方法有哪些？</p><hr><p>2.2本文的主要研究问题和研究任务</p><hr><p>2.3本文的创新点</p><hr><p>三、无线传感器网络</p><p>无线传感器网络是……</p><hr><p>3.1无线传感器网络的结构</p><hr><p>3.2无线传感器网络的特点</p><hr><p>3.3无线传感网络节点结构</p><hr><p>3.4传感器节点的限制因素</p><hr><p>3.5无线传感器的应用</p><hr><p>3.6无线传感器网络覆盖问题</p><hr><p>3.7无线传感器网络覆盖技术参数</p><p>网络生命</p><p>覆盖率和连通度</p><p>算法复杂性与精确性</p><p>工作节点比</p><p>网路可扩展性支持</p><p>算法实施策略</p><hr><p>四、遗传算法概述</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一、摘要&lt;/p&gt;
&lt;p&gt;无线传感器网络是什么？&lt;/p&gt;
&lt;p&gt;无线传感器现状的概述？&lt;/p&gt;
&lt;p&gt;无线传感器的现状？&lt;/p&gt;
&lt;p&gt;无线传感器面临的问题？&lt;/p&gt;
&lt;p&gt;本文讨论的问题?&lt;/p&gt;
&lt;p&gt;关键词？&lt;/p&gt;
&lt;p&gt;二、绪论&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;2.1课题的
      
    
    </summary>
    
      <category term="学士论文相关" scheme="http://yoursite.com/categories/%E5%AD%A6%E5%A3%AB%E8%AE%BA%E6%96%87%E7%9B%B8%E5%85%B3/"/>
    
    
  </entry>
  
  <entry>
    <title>学士论文参考文献</title>
    <link href="http://yoursite.com/2019/04/03/%E5%AD%A6%E5%A3%AB%E8%AE%BA%E6%96%87%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE/"/>
    <id>http://yoursite.com/2019/04/03/学士论文参考文献/</id>
    <published>2019-04-03T06:26:37.000Z</published>
    <updated>2019-04-04T02:26:49.740Z</updated>
    
    <content type="html"><![CDATA[<p>1、基于遗传算法的无线传感器网络优化 孙雁鸣</p><p>2.基于遗传算法的无线传感器网络覆盖优化 江苏大学 曹美霞</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1、基于遗传算法的无线传感器网络优化 孙雁鸣&lt;/p&gt;
&lt;p&gt;2.基于遗传算法的无线传感器网络覆盖优化 江苏大学 曹美霞&lt;/p&gt;

      
    
    </summary>
    
      <category term="学士论文相关" scheme="http://yoursite.com/categories/%E5%AD%A6%E5%A3%AB%E8%AE%BA%E6%96%87%E7%9B%B8%E5%85%B3/"/>
    
    
  </entry>
  
  <entry>
    <title>基于遗传算法的无限传感器网络的优化</title>
    <link href="http://yoursite.com/2019/03/31/%E5%9F%BA%E4%BA%8E%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95%E7%9A%84%E6%97%A0%E7%BA%BF%E4%BC%A0%E6%84%9F%E5%99%A8%E7%BD%91%E7%BB%9C%E7%9A%84%E4%BC%98%E5%8C%96/"/>
    <id>http://yoursite.com/2019/03/31/基于遗传算法的无线传感器网络的优化/</id>
    <published>2019-03-31T14:36:18.000Z</published>
    <updated>2019-04-04T02:46:27.231Z</updated>
    
    <content type="html"><![CDATA[<p>一、摘要</p><p>无线传感器网络=若干个传感器节点（低成本、低功耗、多功能）</p><p>有线网络布网费用高，维护繁琐</p><p>无线传感器网络的最大问题：无线床啊其节点的能量消耗极大，限制了网络的工作寿命</p><p>关键词：无线传感器网络，优化覆盖，遗传算法，优化</p><p>二、绪论</p><p>2.1 课题的研究背景以及研究的意义</p><p>无线传感器网络的研究起源于……</p><p>无线传感器网络=无线通信技术+大量的传感器节点+自组织方式</p><p>大面积环境的数据+不适宜部署有线网络的领域</p><p>无线传感器网络具有成本低、鲁棒性高、功耗小、灵活性高、布网简单、智能化强、维护便捷</p><p>无线传感器大规模投入使用面临的问题：</p><p>能量供应问题：目前的解决方案包括高能电池、传感器网络能量收集技术、降低传感器功率、电池无线充电技术</p><p>节点失效及补充问题：无线传感器网中节点可能会出现周围节点通信不畅或者由于电池能量耗尽而脱离网络，如何修复失效节点或者重新构建网络，有效进行通信。</p><p>成本问题：无线传感器网络在实际使用中需要数量庞大的微型传感器节点，节点的成本就会制约网络的发展。</p><hr><p>国内外研究现状</p><p>传感器网络按照对覆盖区域的不同要求，把覆盖问题分为区域覆盖、点覆盖、栅栏覆盖。</p><hr><p>区域覆盖：柳立峰，在保证足够的网络覆盖能力的前提下，能够关闭掉冗余节点，减少网络的总能量的消耗。区域覆盖要求节点完全覆盖整个目标区域，而如何能够使网络区域中的每个点均被传感器节点覆盖是考虑最多的。</p><p>基于冗余节点判断的覆盖控制算法：</p><p>由于传感器节点分布密度高，某个点或某区域往往同时被多个节点覆盖，称为“覆盖冗余”。</p><p>基于多重K级覆盖算法：</p><p>如果被监测区域的每个点至少在K个传感器节点的感知范围内，则称该网络具有K级覆盖。</p><p>基于网络连通性的覆盖算法：</p><p>如果网络中任意两节点可以进行通信，则该网络是连通的。基于网络连通性的覆盖控制算法的研究目标是保持足够覆盖的前提下，选择最小工作节点数目在位置距离上满足全网通信。</p><hr><p>点覆盖：将传感器节点划分成若干个不相交的集合，每个集合能够完全覆盖所有目标点。任何时刻只要有一个传感器节点集合处于工作状态，其他集合将被依次唤醒。</p><p>点覆盖的优化就是确定不相交集合的最大数，相当于延长了每个传感器两次激活的时间间隔，使得整个网络寿命也得到延长。</p><hr><p>栅栏覆盖：</p><p>栅栏覆盖一般存在于战场环境下，在一片节点部署的区域内，目标可能以任何路径穿过这片区域。栅栏覆盖有两方面的内容：一是要敌方穿越我方区域时不被发现的概率最下；二是我方在穿越地方区域时不被发现的概率最大。</p><p>基于最差情形和最好情形的覆盖算法：</p><p>最大突破路径是指在一条路径上，每一个点距离最近节点的距离最大，那么目标在一定时间沿着这条路径穿越时不被发现的可能性最大。</p><p>最大支持路径：如果存在这样一条路径，其上的每一个点距离最近节点的距离最小，那么目标在一定的时间沿着这条路径穿越时被发现的可能性最大，这条路径就称为最大支持路径。</p><p>基于暴露模型的覆盖算法：</p><hr><p>本文的主要研究内容：</p><p>介绍了无线传感器网络及其特点，并对传感器网络覆盖问题的国内外研究现状进行了分析和归纳。</p><p>采用了遗传算法对节点优化配置，提高了网络的覆盖能力。</p><p>通过MATLAB仿真，验证上述算法。</p><p>2.2 遗传算法的发展</p><p>遗传算法 高度并行 随机 自适应</p><p>基本理念来源于达尔文的遗传学说</p><p>GA在理论上具有解决任何寻优问题的能力，具有极其广泛的应用价值。</p><p>Holland教授 模式定理：优良个体的样本数目将以指数规律增长，从而确保了遗传算法是 一个能够用来搜寻最优可行解的过程。</p><p>2.3无线传感器网络研究的发展状况</p><p>2003年，美国《技术评论》杂志评出了对人类未来生活产生重大影响的新兴科技，被列为第一位的就是无线传感网络技术。</p><p>无线传感器网络最开始被用在军事的监视系统中</p><p>无线传感网络是集通信技术、传感器技术和计算技术于一身的产物</p><p>2.4 本文的应用背景</p><p>无线传感器在露天矿场的边坡检测的例子</p><p>2.5本文研究目的和主要任务</p><p>无线传感器网络最难解决的缺点是：和有线网络相比，无线传感器网络的工作周期极大的受到能源的限制。充电或者更换电池会限制网络中的节点的通信和数据的处理，但是个别节点失灵不会影响整体的工作。</p><p>优化无线传感器网络的关键是延长整个网络的工作寿命。</p><p>2.6 本文的创新点</p><p>三、无线传感网络</p><p>无线传感网络是……</p><p>无线传感网络可以分为动态网络和静态网络两种。</p><p>3.1无线传感网络结构</p><p>无线传感网路主要由传感器节点、任务管理节点、汇聚节点组成。</p><p>传感器节点采集到的数据通过多跳网络或者单跳网络传输到簇头，再到汇聚节点，最终通过卫星或者互联网传输到管理节点。</p><p>传感器节点一般是微型的嵌入式系统，能力较弱，通过携带电池通电。无线传感器网络中汇聚节点的能力比较强，传感器网络和外部网络就是通过汇聚节点相连接的。</p><p>对于多跳网络来说，每个传感器节点必须兼顾终端和路由器的功能，主要功能：信息采集、数据存储和再次的转发。</p><p>对于单跳的网络来说，簇头节点就是路由器和终端。</p><p>3.2无线传感网络的特点</p><p>无线传感器网络相对于其他传统网络的特点：</p><p>组网的规模够大，可以进行动态组网或者静态组网，而且容错性加强</p><p>单跳、多跳、自组织：传感器的通信距离是有限的，当超过一定的距离的时候，自动组成簇，通过多跳的方式从簇头传递到汇聚节点。</p><p>低功耗：环境恶劣，更换电池不容易，所以传感器节点必须是低功耗的。</p><p>数据作为中心：传统网络中，每一个工作节点必须在全网中有唯一的一个编号作为其通信地址；但是在无线传感器网路中，获得所需要的数据是第一要务，数据是从哪里来的是不重要的。</p><p>通信的覆盖范围较小。</p><p>数据处理：传统网络的主要职责是数据传输，自终端上处理数据，中间的节点仅仅负责传输数据；但是对于无线传感网络来说，中间节点同时具备数据传输和数据处理的功能。</p><p>低成本：每个传感器节点都应该低成本，低价格。</p><p>计算能力有限：传感器节点的数目巨大，使得在设计单个节点的时候，要尽量降低制造成本，尽量往微型化方向发展，也使得单个节点自身的运算处理能力地下。</p><p>无线传感器网络规模较大，拓扑结构复杂：传感器节点的精确位置预先不能确定，节点之间的拓扑关系事先也不知道，所以传感器节点要具有一定的自组织能力，能够通过拓扑控制机制和网络协议自动形成监控数据的网络。</p><p>3.3无线传感网络节点结构</p><p>传感网络节点的组成通常是由四部分组成的：处理器模块、传感器模块、能量供应模块、无线通信模块</p><p>数据采集、数据传递、数据处理和能量供应</p><p>3.4传感器节点的限制因素</p><p>电源能量有限：处理器和传感器浪费的能量少，主要消耗在无线通信模块。（此处可以配图说明）</p><p>通信能力有限：E=kd^n。其中参数n的取值在2到4之间，干扰越大n的取值也越大，n的取值通常设置为3，随着距离的增加，能量的损耗也会增加，所以传感器之间的距离应该在100米以内。</p><p>3.5无线传感器的应用</p><p>军事领域</p><p>航空领域</p><p>救灾领域</p><p>工业自动化领域</p><p>电力传输系统</p><p>3.6无线传感器网络覆盖问题</p><p>根据覆盖对象的不同，将静态无线传感器网络的覆盖问题分为三类：区域覆盖、点覆盖、栅栏覆盖</p><p>区域覆盖要求目标区域内的每个点至少被一个节点覆盖；</p><p>点覆盖考虑的是对若干离散目标点的覆盖，节点随意部署在若干个离散目标点附近，将节点划分为若干个互不相交的节点，使得集合能够完全覆盖这些目标点。任意时刻只有一个节点集合工作，使其他集合全部处于休眠状态。</p><p>栅栏覆盖：关注网络对移动目标的检测能力，当移动目标沿着任意路径穿越网络部署区域，目标不被发现的概率最小。</p><p>3.7无线传感器网络覆盖技术参数</p><p>网络生命：传感器网络的监控使长期的，尽管单个传感器节点的成本随着微电子技术的发展不断进步而降低，但是数量众多的传感器节点费用仍旧比较高；并且单个节点的能量十分有限，传感器节点工作的环境一般十分恶劣，更换电池基本上不可能。如何最大程度的降低节点的能耗来延长网络的生命期是当前研究的一个重要问题。</p><hr><p>覆盖率和连通度：覆盖率是指所有传感器覆盖的总面积与目标区域总面积的比值，覆盖率小于等于1.</p><p>连通度则是指网络中的任何一个节点都要至少与网络中的其他几个节点相连通，连通度至少为1.</p><hr><p>算法复杂性与精确性</p><p>算法复杂度包括网络运行时间复杂度、算法的实现复杂度、网络内部节点之间的复杂同心度。算法的准确性，用来降低算法的复杂度，提高网络运行效率。</p><hr><p>工作节点比</p><p>任一时刻工作节点的数量都小于网络中所部署的节点数量。在保证覆盖的服务质量，工作节点数量越小，网络能量消耗越小，则算法越有效，进而延长网络生存寿命。</p><hr><p>网路可扩展性支持</p><p>节点的丢失与参与要求网络的可扩展性，没有可扩展性做保证，网络性能会随着规模的增加而降低。</p><hr><p>算法实施策略</p><p>覆盖控制算法有三类：分布式、集中式、混合式</p><p>集中式算法的能量消耗较大、网络性能和算法精度较差。</p><p>分布式算法利用本地信息，能耗能量较小且网络性能等方面都较好。</p><p>四、遗传算法概述</p><p>遗传算法受到了生物进化理论的启发，GA以自然界中的优胜劣汰和生物遗传机制作为理论的基础。</p><p>简单阐述遗传算法的概念。</p><p>4.1基本遗传算法</p><p>Goldberg研究出的传统的GA，只使用选择算子、交叉算子和变异算子，是GA的雏形。</p><p>编码方式：二进制编码、浮点数编码、量子编码</p><hr><p>适应度函数：适应度函数和目标函数，求解最大值和最小值的问题</p><p>适应尺度变换：所谓的适应尺度变换，就是为了解决GA在初期的早熟问题和GA在后期的竞争力变弱的问题。</p><p>GA初期的早熟问题：假设个体的数目相对较少，如果此时群体中有一部分个体的适应度相对较高，那么他们遗传到下一代的概率就会非常高，但是过多的相似的个体进入下一代之后，他们经过交叉和变异产生的后代的多样性会减少，导致GA的早熟现象。早熟问题的出现主要就是由选择算子的不当造成的。</p><p>GA的早熟现象的解决办法：在GA运行的初期，将排名靠前的那一部分的个体的适应度相对调低，使其进入下一代的比例相对减少，保持下一代的多样性。</p><p>GA运行到后期，由于全部的个体其实已经逐渐的逼急最优解，此时，大家的适应度相差不大，就会导致竞争的逐渐变弱，最后使得竞争变成了随机的选择。</p><p>GA后期的解决办法：当GA运行到后期的时候，把排名相对靠前的一部分的个体的适应度相对调高，提高竞争性，但是同时不能改变排名的原有顺序。</p><p>尺度变换的三种方法：线性尺度变换、乘幂尺度变换与指数尺度变换</p><p>线性尺度变换：F’=aF+b,其中F是原适应度。</p><p>a和b一般需要满足的条件：尺度变换后原种群的适应度的平均值等于全部种群中个体的新适应度的平均值（是否代表，前后的平均值需要保持一致？）；尺度变换后的最大值要与原适应度平均值的指定倍数要相等，就是F’max=CFmax.</p><p>乘幂尺度变换：新的适应度是原有适应度的幂次。</p><p>指数尺度变换：</p><hr><p>选择算子</p><p>选择操作就是指从旧的种群中以一定的概率选取若干个个体遗传到下一代群体中，选择操作的是建立在适应度的评价的基础上。</p><p>GA的早熟问题就是选择算子的不当造成的，导致进化停止不前或者种群中适应度较大的个体会误导种群进化的方向，使遗传失去了多样性。</p><p>常见的选择操作策略：轮盘赌、随机竞争、最佳保留、均匀排序选择和随机联赛选择</p><p>选择选择操作策略与编码方式无关。</p><hr><p>最优保存策略</p><p>由于适应度最佳的个体可能在选择、交叉和变异的过程中被破坏掉，种群的平均适应度会因此而降低并且会很大程度上影响到GA的运行效率以及收敛性，而且GA运行的过程中要尽可能的将种群中适应度最好的个体保留到下一代。</p><p>为了实现上面的目的，我们可以采用最优保存策略来完成优胜劣汰操作，任何交叉和变异操作都会对当前种群中适应度最高的个体失效，用这个最好的替换经过选择交叉变异后所产生的新一代中的最差的个体。</p><p>最优保存策略同样存在问题，它容易加速某个最优个体的扩散，算法的全局搜索能力受到了极大的限制，因此最优保存策略必须配合其他一些选择操作方法来使用。</p><hr><p>交叉算子</p><p>交叉运算就是指从种群中选取两个个体，随机选择一点或者多点染色体进行位置交换，通过两个染色体的交换组合，来产生新的优秀个体。</p><p>交叉算法也是遗传算法区别于其他算法的主要特征。</p><p>常用的配对算法策略是：将种群中的M个优秀个体随机打乱，再组成M/2个配对个体组。</p><p>个体编码和交叉算子的设计必须被统一考虑。</p><p>单点交叉：设染色体的长度为L，则共有L-1个可能的交叉点位置，在[1，L-1]的范围内，随即的选区一个整数数值K作为交叉点，然后交叉K点之后的基因片段。</p><p>两点交叉：交叉的是两个点之间的基因片段。</p><p>算术交叉：算术交叉是指通过线性组合的两个父代个体出产两个新的个体，只是只有浮点数编码的个体才能进行算术交叉运算。</p><p>量子交叉：当两个相同的个体出现的时候，普通的交叉方法在遗传算法的运行中就不会再奏效。</p><p>但是量子具有相干的特性，我们可以利用量子的这个特点，构造出一种全新的交叉操作，全干扰交叉。</p><hr><p>变异算子</p><p>变异操作是指个体编码串中的某些基因值变成其他的数值。</p><p>变异算子有效的维持了种群的多样性，早熟现象的得到了很好的控制。</p><p>基本位变异：指定某一位或者某几位基因的变异概率。这种操作方式只能改变几个基因的数值，而且变异发生的概率相对较低，作用的效果也不是很明显。</p><p>均匀变异：每个基因都有一定的概率产生变异。均匀变异适合应用在GA运行的初期。</p><hr><p>遗传算法运行参数</p><p>遗传算法中需要提前设定的算法参数主要有：种群的大小M、终止进化的代数G、交叉概率Pe、变异概率Pm等。</p><p>种群大小的选择：种群数目过小，容易引起遗传算法的早熟，种群的数目过大，则会导致遗传算法的速度降低。M的取值范围通常应该是20-100.</p><p>终止进化代数G：决定遗传算法运行的到哪一代停止。</p><p>交叉概率Pe：当交叉概率过大的时候，种群的优良模式会很容易受到破坏，但是交叉概率过小的时候，产生新的个体的速度会变慢。取值通常应该在0.4-0.99比较合适。</p><p>变异概率Pm：取值过大，种群中较好的个体可能被破坏掉；当取值过小，产生新个体和抑制早熟就会比较差，变异概率的通常取值是0.0001-0.1.</p><p>五、无线传感网络模型构造</p><p>5.1网络模型</p><p>10*10的正方形网格，传感器节点被放置在网格的100个交叉点上。假设传感器是相同的，但是传感器的状态是不同的。这里假设传感器节点能量是可以控制的，可以人为的在基站调节传感器节点的发射功率。</p><p>节点被分到不同的簇，每一个簇中选出一个节点作为簇头，簇中的节点直接与簇头进行通讯（单跳），簇头与远程基站进行通讯（单跳）</p><p>簇头的能量消耗比较大。</p><hr><p>无线传感器的网路覆盖类型：</p><p>根据应用可以分为时间驱动类型和事件驱动类型。（时间驱动类型是指按照时间启动，事件驱动类型是指只有当发生一定的事件才会启动，Q：是否是指没有发生事件的时候，传感器处于一种低功耗的问题）</p><p>根据覆盖对象，静态传感器网络可以分为：目标覆盖、栅栏覆盖和区域覆盖。（Q：什么是栅栏覆盖）</p><p>根据节点的部署方式，可以分为节点确定性部署，随机性部署以及可移动部署。</p><p>根据节点的类型，可分为同构节点覆盖、异构节点覆盖以及混合节点覆盖等。</p><hr><p>从应用角度归纳覆盖的分类</p><p>按目标特性：静态目标覆盖和动态目标覆盖。静态目标覆盖主要考虑的是覆盖的全面性以及对覆盖冗余节点的处理。</p><p>按配置方式：根据节点是否需要知道自身位置信息，可以将覆盖问题分为确定性覆盖、随机性覆盖。随机覆盖所要解决的问题是对节点随机分布在传感区域而预先没有得到自身位置及进行讨论。</p><p>按感知类型：目前的感知类型主要有两类：二进制感知模型和指数感知模型。</p><p>5.2适应度函数的建立</p><p>休眠参数</p><p>休眠节点误差：用来限制无线传感器网络中休眠节点的数量。当无线传感器网络休眠节点的数目超过总节点数的50%的时候，网络的连通性就会受到破坏。</p><hr><p>连通性参数</p><p>节点覆盖率：</p><p>簇中节点个数误差：每个簇最多携带的节点数目应该是有限制的。</p><p>超限节点误差：统计超出通信距离的传感器节点占整个网络节点数的比例。</p><hr><p>能量参数</p><p>网络总体能量的消耗：簇头节点、高功率发射节点、低功率发射节点、休眠节点，其中休眠节点的能耗为0；</p><p>通讯能量损耗：节点与簇头节点进行通讯所消耗的能量。</p><p>电池惩罚值：影响节点下一个周期的工作状态，从而使网络的工作时间最长。</p><p>六、基于遗传算法无线传感网络能量优化实验</p><p>6.1 串行遗传算法实验</p><p>网络中节点的四种工作模式：簇头模式、休眠模式、高功率发射模式、低功率发射模式。</p><hr><p>编码机制</p><p>采用二进制编码，01编码即可</p><p>经过实验种群数目是80，单点交换概率为0.8，突变概率为0.005，适应度的数值最大。</p><p>尽量可能让运行能量消耗最小，簇头节点减少，低功率发射节点增加，高功率发射节点减少。</p><p>6.2 并行遗传算法实验</p><p>使用串行遗传算法进行实验，要进行大量适应度的计算，所以进行并行遗传算法。</p><p>应用基于种群进行分组遗传算法，一个种群划分成多组种群，把划分好的子种群及遗传算法分别放置在不同的电脑上。</p><p>将各个电脑上的程序和数据运行一个周期，将各个电脑之间再以适当的方式进行一些信息的交换。</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一、摘要&lt;/p&gt;
&lt;p&gt;无线传感器网络=若干个传感器节点（低成本、低功耗、多功能）&lt;/p&gt;
&lt;p&gt;有线网络布网费用高，维护繁琐&lt;/p&gt;
&lt;p&gt;无线传感器网络的最大问题：无线床啊其节点的能量消耗极大，限制了网络的工作寿命&lt;/p&gt;
&lt;p&gt;关键词：无线传感器网络，优化覆盖，遗传算
      
    
    </summary>
    
      <category term="学士论文相关" scheme="http://yoursite.com/categories/%E5%AD%A6%E5%A3%AB%E8%AE%BA%E6%96%87%E7%9B%B8%E5%85%B3/"/>
    
    
      <category term="遗传算法" scheme="http://yoursite.com/tags/%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95/"/>
    
      <category term="无线传感器网络优化" scheme="http://yoursite.com/tags/%E6%97%A0%E7%BA%BF%E4%BC%A0%E6%84%9F%E5%99%A8%E7%BD%91%E7%BB%9C%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>初识遗传算法</title>
    <link href="http://yoursite.com/2019/03/31/%E5%88%9D%E8%AF%86%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2019/03/31/初识遗传算法/</id>
    <published>2019-03-31T03:04:59.000Z</published>
    <updated>2019-04-03T01:03:12.123Z</updated>
    
    <content type="html"><![CDATA[<p>一、遗传算法基本知识</p><p>1.遗传算法的遗传操作：选择、交叉、变异（选择出好的近似解，然后进行交叉和变异，就会产生新的种群）</p><p>交叉(crossover)：两个染色体的某一相同位置处DNA被切断，前后两串分别交叉组合形成两个新的染色体。也称基因重组或杂交；</p><p>2.遗传算法的核心内容：参数编码、初识群体的设定、适应度函数的设计、遗传操作设计、控制参数</p><p>适应度：度量某个物种对于生存环境的适应程度。</p><p>3.遗传问题是从种群开始的，种群是由个体组成的，个体实际上是染色体带有特征的实体。染色体中控制某一特征的基因组合，决定了该特征的外在表现形式，所以在一开始需要实现从表现型到基因型的映射，即编码工作。</p><p>4.遗传算法可以看作是多元函数求最优解，多元函数可能存在很多的极大值或者极小值，遗传算法就是找出其中的最大值或者最小值。</p><p>寻找最大值的方法就像袋鼠跳，我们希望袋鼠会跳到最高的位置。</p><p>5.袋鼠跳的几种方式</p><p>爬山算法：一只袋鼠在一个山峰，于是朝着不远处的另一个更高的山峰跳过去，但是第二个山峰不一定就是最高的。局部的最优解不一定是全局的最优解，有可能更远的地方有一个比现在的山峰还要高的山峰，但是那个山峰超出了袋鼠的跳跃范围（或者说认为设定的约束条件）</p><p>模拟退火：</p><p>遗传算法：有很多袋鼠，它们降落到喜玛拉雅山脉的任意地方。这些袋鼠并不知道它们的任务是寻找珠穆朗玛峰。但每过几年，就在一些海拔高度较低的地方射杀一些袋鼠。于是，不断有袋鼠死于海拔较低的地方，而越是在海拔高的袋鼠越是能活得更久，也越有机会生儿育女。就这样经过许多年，这些袋鼠们竟然都不自觉地聚拢到了一个个的山峰上，可是在所有的袋鼠中，只有聚拢到珠穆朗玛峰的袋鼠被带回了美丽的澳洲。</p><p>二、遗传算法的实现过程</p><p>1、建立表现型和基因型的映射关系</p><p>假设我们需要找出最适应在寒冷地区生存的人类的某一条染色体的编码，假设该染色体上有十个基因片段，十个基因片段的排序决定了人类对于寒冷的耐受性。</p><p>2.随机初始化一个种群</p><p>随机初始化一个种群，意味着这一个种群中人，十个基因的排列顺序的速记排列的。</p><p>3.适应度的评估</p><p>接下来测试每个人对寒冷的耐受能力，当然是越能忍受寒冷越好。</p><p>4.选择</p><p>按照某种规定做优化的选择，比如每隔一段时间淘汰掉耐受能力最后的20%。</p><p>5.基因的交叉</p><p>让生存下来的人类繁衍后代，然后产生下一代袋鼠。</p><p>6.基因的变异</p><p>让存活下来的一部分的基因序列随机改变一下排序。（应规定随机变异的程度，比如不能超过四个基因的位置变化之类的，或者不允许第一个和最后一个基因突变）</p><p>总结：遗传算法不需要费心去寻找最优解，而是把那些不好的存在抹杀就可以了.</p><p>三、遗传算法的具体实现</p><p>1、编码</p><p>遗传算法的编码主要有三类：二进制编码、浮点编码、符号编码、量子编码</p><p>1.1二进制编码：就是用0和1进行编码</p><p>二进制编码的缺点：个体长度较短的时候，可能达不到精度的要求；个体长度较大的手，会增加遗传算的搜索空间（当个体的长度较短的时候，比如只有两个01、00、10、11，假设寻找会使人的头发显现黑色基因，通过最简单的比较就可知道那两个比较好，假设是11和10，利用这两个进行杂交会出现的结果就是10和11，这时候就无法判断到底是哪个比较好了）（当个体的长度过长的手，交叉或者变异之后的变数会增大，会给搜索最佳算法增加难度）</p><p>假设用ｎ位二进制来编码，则二进制编码的精度是（Umax-Umin）/(2^n-1),</p><p>1.2浮点编码：个体的每个基因值用某一范围内的一个浮点数来表示</p><p>浮点编码的优点：</p><p>适用于在遗传算法中表示范围较大的数值</p><p>适用于精度要求较高的遗传算法</p><p>适用于较大空间的遗传搜索</p><p>降低了遗传算法的计算复杂性，提高了运算的速率</p><p>1.3符号编码法</p><p>1.4量子编码方法</p><p>每一个量子位除了0或者1以外，还可以处于两者的叠加状态，叠加状态是指0和1的任意线性叠加。</p><p>2、袋鼠的染色体编码</p><p>3、评价个体的适应度-适应度函数</p><p>目标函数与适应度函数：求解最大值和最小值的问题</p><p>求解最大值的问题</p><pre><code>F(X)=f(X)+Cmin,if f(X)+Cmin &gt; 0    =0        ,if f(X)+Cmin &lt;= 0    其中Cmin为一个相对较小的数</code></pre><p>求解最小值的问题</p><pre><code>F(X)=Cmax-f(X),if f(X)&lt;Cmax    =0        ,if f(X)&gt;Cmax</code></pre><p>适应度尺度变换</p><p>GA的早熟现象：GA运行的初期阶段，如果种群的数目相对较小，而且在种群中存在一部分适应度相对比较好的个体，这些个体就会比较容易生存下去，这些相同或者近似的个体繁殖出来的下一代，多样性会受到影响，这就是GA的早熟现象.</p><p>GA的早熟现象的解决办法：我们可以在初期降低那些适应度的数值相对较高的个体的适应度，使其在下一代中的比例相对降低，但是同时又不会改变排列顺序（这就是适应度的缩小）</p><p>GA运行的后期阶段：在GA运行的后期阶段，因为种群中所有个体的适应度相差不大，就会导致竞争变弱，导致竞争过程变成一种随机的选择过程，因此在此时我们需要将那些排名相对较高的个体的适应度调高一些，但是同时不改变排列的原有顺序。（这就是适应度的扩大）</p><p>适应尺度的变换一共有三种变换方法：线性变换、乘幂变换、指数变换</p><p>线性变换：F=aF+b ,其中a和b的数值要满足一定的条件。</p><p>新的种群适应度的平均值要和原有的种群适应度的平均值保持一致；而且新的种群的最大的适应度的数值，应该满足Fmax=CFmax</p><p>乘幂变换：</p><p>尺度变换：</p><p>4、选择函数</p><p>轮盘赌选择：个体进入下一代的概率=个体的适应度数值/整体的适应度数值和（选择误差比较大）</p><p>随机竞争选择：每次按照轮盘赌选择一对个体，然后让这两个个体进行竞争，适应度高的被选中，如此反复。（但是轮盘赌选择的个体是如何选择的）</p><p>最佳保留选择：首先按轮盘赌选择方法执行遗传算法的选择操作，然后将当前群体中适应度最高的个体结构完整地复制到下一代群体中。（那么适应度不高的个体应该如何选择）</p><p>期望值选择：第一步，计算群体中每个个体在下一代群体中的生存期望数值N；第二步，若某一个体被选中参与交叉运算，则它在下一代中的生存期望数目减去0.5，若某一个体未 被选中参与交叉运算，则它在下一代中的生存期望数目减去1.0。（此处的选择是如何选择的）；第三步，随着选择过程的进行，若某一个体的生存期望数目小于0时，则该个体就不再有机会被选中。</p><p>确定式选择：第一步，计算群体中的各个个体在下一代群体中的生存期望数目；第二步，用N的整数部分确定各个对应个体在下一代群体中的生存数目；第三步，用N的小数部分对个体进行降序排列，顺序去前M个个体加入下一代群体中。（假设得出来的N的数值分别为3.1、3.2、3.5、4.5、5.5，表示每一个在下一代中的期望的数目有3、3、3、4、5，其中3的有三个，所以可以降序排列，取第一个，就是3.3）</p><p>无回放余数随机选择：</p><p>均匀排列：对群体中的所有个体按照适应度的大小进行排序，根据排序来分配每个个体被选中的概率。</p><p>最佳保存策略：适应度最高的不参与交叉和变异运算，而是用这个来代替，经过交叉和变异之后，适应度最低的个体。</p><p>随机联赛选择：随机选取N个，然后将适应度最高的一个个体遗传到下一代中。</p><p>排挤选择：新产生的子代，会替代或者排挤相似的旧的父代的个体，提高群体的多样性。</p><p>5、交叉</p><p>所谓交叉，是指相互配对的两个染色体，按照某种方式交互部分基因，从而形成两个新的个体。</p><p>适用于二进制和浮点编码个体的交叉算子：</p><p>单点交叉：只有一个交叉点，在该点交换部分染色体。</p><p>两点交叉和多点交叉：</p><p>均匀交叉：每个基因片段以相同的交叉概率进行交换，形成两个新的个体。</p><p>算术交叉：由两个个体的线性组合而产生出两个新的个体。该操作对象一般是由浮点数编码表示的个体。</p><p>6.变异</p><p>所谓变异，就是指某个基因，用其他等位基因来替换。</p><p>变异算子：</p><p>基本位变异：对个体编码串中以变异概率、随机指定的某一位或某几位仅因座上的值做变异运算。</p><p>均匀变异：用一个范围内的随机数，替换编码串中的原有数值（用一个较小的概率）</p><p>边界变异：随机的取基因座上的两个对应边界基因值之一去替代原有基因值。特别适用于最优点位于或接近于可行解的边界时的一类问题。（什么是边界基因值）</p><p>非均匀变异：</p><p>高斯近似变异：</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一、遗传算法基本知识&lt;/p&gt;
&lt;p&gt;1.遗传算法的遗传操作：选择、交叉、变异（选择出好的近似解，然后进行交叉和变异，就会产生新的种群）&lt;/p&gt;
&lt;p&gt;交叉(crossover)：两个染色体的某一相同位置处DNA被切断，前后两串分别交叉组合形成两个新的染色体。也称基因重组或杂
      
    
    </summary>
    
      <category term="学士论文相关" scheme="http://yoursite.com/categories/%E5%AD%A6%E5%A3%AB%E8%AE%BA%E6%96%87%E7%9B%B8%E5%85%B3/"/>
    
    
      <category term="遗传算法" scheme="http://yoursite.com/tags/%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>123</title>
    <link href="http://yoursite.com/2019/03/07/123/"/>
    <id>http://yoursite.com/2019/03/07/123/</id>
    <published>2019-03-07T10:38:30.000Z</published>
    <updated>2019-03-07T10:38:30.192Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
</feed>
